WOULD BE NICE:

    ----------------------------------

    Would be nice if demos could specify whether they want to clear the screen or not.

    For example, cubes demo does want to, but the stone demo does not.

    ----------------------------------

    Clean up all the excessive namespace usage inside cubes source code.

    Everything should be uniformly inside "cubes" namespace. Nothing more.

    ----------------------------------

    "magic number" enums like 0 = block message, 0 = connection packet type, CONTEXT_USER and so on,

    They're error prone and easy to fuck up. And hard to track down. Is there a better way?

    ----------------------------------

    Consider renaming "ChannelStructure" to "ConnectionContext"?

    ----------------------------------

    Remove extra "ClientServer" prefix and "CLIENT_SERVER_" prefix where they are redundant.

    ----------------------------------

    Clean up network and prefix all files with "Network*", eg: NetworkEnums.h, NetworkInterface.h, NetworkSimulator.h etc.

    ----------------------------------

    Channel should be renamed to "ConnectionChannel" (so its association is clear...)

    Channel structure should be renamed to "ConnectionChannelStructure"
    
    ----------------------------------

    If serialize was split out from protocol it would provide a nice serialization layer
    without any protocol specific baggage.

    eg. this would be nice for other people to use in their own protocols, if they didn't
    quite want to use my protocol implementation.

    ----------------------------------

    Generally it's annoying having "Enums.h" across different directories.

    Standardize and for things like this, prefix with the type, eg. "ProtocolEnums.h", "ClientServerEnums.h" etc.

    ----------------------------------

    Network simulator maybe is really a part of protocol. It doesn't really "work" as per-network
    type send/recv should work, eg. blocks of packet data, it works on protocol packets.

    It would be really nice if protocol layer didn't actually depend on network library at all. It shouldn't really.

    ----------------------------------

    Prefix all tests with the module, eg. test_virtualgo_*, test_cubes_* and so on

    ----------------------------------

    Finish implementing virtual go tests for each stone vs. board collision type

    ----------------------------------

    It's important that tests are able to be run in release, but currently they do checks via CORE_ASSERT
    which is debug build only. This is wrong!!!

    ----------------------------------

    tests/common -- a place for stuff common to all tests, eg. so it is kept out of runtime code
    
    For example, CHECK, CHECK_CLOSE, CHECK_CLOSE_VEC3 and so on.

    ----------------------------------

    Virtual go project has a lot of unneccessary implementation in headers.

    Fix it so it has better header leakage, eg. faster compilation for cpps.

    ----------------------------------

    Idea of a packet serializer/deserializer, eg. an interface to do this

    Networking relies on this existing, but doesn't care about its implementation

    Alternatively, rework network layer to only care about packets as blocks of data
    and rely on protocol layer to perform the deserialization.

    Frankly, this second option seems smarter and simpler!
    
    ----------------------------------

    Split out client and server from protocol so protocol isn't bound to client/server implementation

    ----------------------------------

    Fix activation problem in cubes test, eg. object does not reactivate when moved, unless the activation point is set.

    ----------------------------------

    Cubes library uses STL. Fix this!

    ----------------------------------

    A nice script or program that automatically converts all out of data
    cubemap data from assets, but only as needed (as they are expensive)

    ----------------------------------

    Convert the cherry blossoms to a .dds cubemap cross format.

    Try out the cherry blossoms cubemap in game

    ----------------------------------

    Implement nice model "ModelBegin" and "ModelEnd" functions (select shader, VAO etc.)

    Implement nice helper functions for model to bind shader locations etc.

    eg. for vector type, matrix4 type, matrix3 type, vec4, vec3, float, integer...

    Convert existing shader location setup to use helper functions.

    ----------------------------------

    Implement model manager and cache models as created.

    How to identify models? They're really unique things without 1-1 mapping to filename.

    I think I need a general resource handle concept.

    Models tend to refer to other resources. Models should know when any of their
    dependencies have changed, so they know to recreate themselves.

    This means I think that handles should be built with dirty flags in them,
    or at least sequence numbers per-resource flag, so when you get that resource
    you can ask "is it the same as when I got this handle". If the answer is no,
    you can reload it.

    In fact this reloading could be made automatic.

    ----------------------------------

    Seems the model manager should be in charge, eg. it should drive loading of models
    and shaders and textures.

    You should ask to reload a model.

    It's probably not reasonable to just reload shaders, or just reload models.

    If you reload shaders or models, any models must be marked dirty that reference
    these shaders.

    This means these managers must track references.

    This could get a bit tricky. Need to design something smart.

    ----------------------------------

    Model manager should detect when either shader, or mesh is dirty and
    recreate all of the stuff on top (eg. instance buffer, VAO and all its setup)
    at will.

    This will allow the code to easily handle dynamically reloading mesh data,
    texture data, shaders...

    Must be coded this way from the beginning so the code is designed to handle this.

    ----------------------------------

    Implement different rendering for white and black stones via per-instance data

    For example, the base ambient color and diffuse color and shininess should be
    passed in via vertex attributes (per-instance).

    This makes more sense vs. uniforms because I'm going to want to vary this data 
    per-instance to do the gradient between roughness / metal for the stones with PBR.

    ----------------------------------

    Code a tool that actually compiles the shaders to check that they compile before going fullscreen.

    It's annoying to work on shaders and continually have them not compile properly and having to quit out of the app.

    ------------------

    When stones are reloaded we need to detect this, and potentially load the new stone mesh if it is different.

    Currently there is no code that will delete the old stone mesh

    Make sure that within the demo framework there are reload callbacks that identify to the demo when
    types of assets were reloaded, so the demo can do any demo specific work it needs to do, eg. unloading
    all existing meshes and invalidating cached meshes if they were reloaded.

    ------------------

    Provide a way for the demo to render some debug overlay,

    eg. text "Size 40" for the go stone, bottom right.

    ------------------

    Implement two modes of console:

        1. Quick entry mode, ~, type in command and then enter to execute. esc or ~ cancels

        2. Full console mode -- black alpha quad, text history of command execution (double ~~ or alt-~)

    ------------------

    Implement console text buffer.

    Implement proper log, warning, error functions (printf style)

    Color the commands, logs, warning, errors differently so they are easy to read in the console buffer

    Implement pageup pagedown within this buffer somehow (scroll events?)

    (Sublime text uses function up/down for scrolling, apple up/down for top/bottom of buffer -- this is nice!)

    ------------------

    Actually implement proper args parser.

    Should strip pre/post whitespace, handle "" open/close quoting (and remove the quotes to form an argument),
    after this should tokenize on 

    Ideally args should be parsed *before* executing the command, that way they could work in-place in the command buffer
    and just pass a nice array of strings ptrs to the client, with appropriate '\0' added to string to make it work.

    ------------------

    Implement +command args and -something args parser for command line arguments.

    This will let me run the game like "Client +demo stones" while iterating on a particular demo.

    ------------------

    Need to do something so text is the same size between retina (windowed) and non-retina display (fullscreen)

    -------------------

    Would be really nice if each demo had its own memory heap to work within, eg. allocator for the demo

    -------------------

    Is it possible to switch between fullscreen and windowed dynamically with glfw?

    It would be really nice if this was possible, and I could type "fullscreen"
    and "windowed" as console commands.

    It's not possible without recreating the window fully.

    This invalidates all shaders, textures, meshes and such, meaning that they all
    must be recreated.

    This is *probably* a worthhile exercise to do once the demo is working,
    make sure it is resilient to completely having window and context destroyed
    and recreated.

    It is important for the demos to be designed to support this, eg. the reload
    functionality, so I think that switching windowed/fullscreen like this should
    be no additional work beyond what should be implemented for that.

    ------------------

    Implement function auto complete, eg. press tab and it matches the exact function name if exists

    If multiple functions exist, complete only up to the shared characters between all functions

    Implement a drop list UI that displays all the matches

    Selection while the droplist is up can be performed via up/down

    Escape while the droplist is up removes it.

    ----------------------------

    Consider using flatbuffers to communicate between tools and runtime.

    Would save on implementing annoying file IO and stuff, and maintaining binary compat.

    Probably fast enough for anything too.
    
    ------------------------------

    Get the virtual go tests running and passing, eg. TestVirtualGo.cpp

    Restructure the virtual go code so it's simple and compiles quickly without exposing too much impl in headers.

    Clean up awful shader loader code iostream and std::string bullshit

    ------------------------------

    Fix up the creation of the game client so it's not stupid.

    Fix up the game client memory leaks on shutdown. 

    It's important to detect leaks as soon as they happen!

    ------------------------------

    I would like a JSON scene language that describes what objects to create and where to place them.

    This will allow me to create demo scenes for go board and work on renders without writing C++ code
    to place the objects.

    Alternatively, I could embed a scripting language and use that to set up scenes.

    ------------------------------

    I would like a texture manager (seems that OpenGL does most of this, but could make it a bit easier...)

    By tracking all the textures loaded from disk, we can reload them as required, eg. reload textures.

    ------------------------------

    Implement gaussian blur for shadow

    Good article here:

    http://www.roxlu.com/2014/045/fast-opengl-blur-shader

    ------------------------------

    Need to clean up the way I read and write to files.

    The binary read/write using ad-hoc stuff is a bit ugly.

    It would be nice to have a standardized file wrapper to do this,
    with a bit less effort, eg. File class.

    ----------------------------

    Create a new "tool" library (or tools/common) and put the mesh code in there.

    This lets me write non-trivial code that is not suitable for runtime,
    but is available across multiple tools, eg. the "ToolMesh"

    Split tool mesh into .h and .cpp

    Make sure tool common is not built when building the game runtime.

    ---------------------------

    Ideally, the go stone would be chopped such that when interacting
    go stone to go stone, the biconvex is chopped, as per a cylinder
    at the point of the bevel edge.

    This would allow stones to appear to sit flush next to each other.

    ---------------------------

    It's annoying and complicated to create a game server.

    It's really nice that it's completely configurable,
    but the config being passed in to the constructor makes it
    difficult to create a derived class that just creates how
    it wants to.

    Maybe an init method would be a better idea? Even if it's internal...

    I really want the game client and server to be self contained, eg. own all objects they use

    ---------------------------

    I want the client to have callbacks for pretty much everything that happens, eg. 
    te be able to get callbacks on client connect, disconnect, to be able to override
    packet receives (eg. process more packet types) and so on.

    ---------------------------

    The network simulator is coded in such a way that it is annoying to use
    for a real application. I don't want it to randomly cycle between settings
    automatically. I want the user to be able to choose between a series of presets.

    ---------------------------

    It's really annoying not being able to create an address passing in dynamic port,
    eg. Address( "::1", ServerPort ) should be a thing.
    
    ---------------------------

    Client connect takes over 1 second. Optimize!

    ---------------------------
    
    Network library should not depend on protocol. Work out how to split them apart.

    ----------------------------------

    Put tool binaries into bin/tools instead of bin directly. This way tools can be easily excluded from the shipping product.

    Setup a path so bin/tools are available from anywhere. I want my tools!

    Font builder should delete any *.font files that don't match entries in the JSON as a post-step
    (eg. stale font files stick around otherwise when you restructure the JSON)

    JSON file that describes all the heaps (and subheaps to create), by name, how large etc.

    This would be super great to split up memory into different heaps with different sizes, eg.
    "fonts", "network", "textures", "level" and so on.

    Some of the heaps could be static, eg. stuff that should exist even if level isn't loaded.

    Other heaps could be subheaps specified inside the level heap, by the code that runs
    for that particular level.

    -----------------------------------

    Might be possible to hash packet with client/server guid + packet data,
    and then the overhead for the packet would become the hash, not the 
    client/server guid combination -- which is cool!

    -------------------------------

    I would like a small block of data (smaller than one packet) 
    that could be included with the client connection request,
    and with the server connection accepted.

    This would provide a way for subclassed client and server to
    extend the protocol and pass data up/down at initial point
    of connect, this is necessary functionality as integrations
    will probably want to extend connect with custom logic and data.

    -------------------------------

    Will probably remove the "CLIENT_SERVER" prefix, they are just packets.

    Packets may not always be used as part of client server. Packets are generic.

    -----------------------------

    Should probably move resolver tests out of unit tests, and create a new "test_resolver"

    It is too slow (in terms of real time), to run amongst the other tests.

    -----------------------------

    Would be nice to create an address by string, and then have a port override arg

    ----------------------

    Clean up the resolver so that it doesn't perform dynamic allocations.

    Find a way to move the future into the implementation (cpp)
    so we don't need #include <future> in a header file.

    Remove std::string usage from Resolver interface and DNSResolver.

    ----------------------

    Should be able to determine if scratch allocator is being exhausted,
    and falling back to malloc, eg. add a check, and then check this once
    per-frame inside the soak test -- i definitely *dont* want the scratch
    falling back to malloc inside soak test.

    Alternatively, add a flag so it asserts if it has to fallback to scratch,
    but disable this by default because otherwise it won't pass the unit test.

    -------------

    I would like the scratch allocator to be more resilient in  debug builds, 
    eg. for it to have safety checks, eg. missing magic # where expected, assert.

    ----------------------

    Google have some cool allocators. Check them out.

    ----------------------

    Add some macros to make defining serialization and messages easier.

    ----------------------

    Basic logging. Just start with a "Log" macro that can be redirected
    to a "Logger" interface via virtual fn. 

    Of course, this is disabled in release build (NDEBUG) but it is 
    the easiest way to make sure the library can output logs to the
    appropriate place (console, TTY, file, whatever...)

    Should logs include the "\n" at the end?

    It would be nice if they didn't have to. It's easy to forget.

    --------------------

    Optimization for fragments, track oldest unacked fragment id, and start there
    and go left to right to search for fragments to send.

    --------------------

    Add a new fragmentSendWindow config, eg. 64 and only look this far past
    the oldest unacked fragment. Should save unnecessary scans for large block
    sizes.

    --------------------

    Could save a bit of memory and maybe gain some speed by switching 
    the received fragment data to a bitfield

    We only need one bit per-fragment, "has it been received?"

    ----------------

    Idea for logging, have an enum of channels, and per-channel a level integer
    Initial level is zero. Enable logging by setting the level. Per-channel logs
    can be emitted by passing the level, which defaults to 1.

    Log( "hello everybody %d\n", value );

    On a per-file basis, specify the current log channel via #define

    This may require the project gets split up into cpp files first.

    ----------------

    For the message and block allocator, I'm thinking of a thread
    local storage allocator that detects when the thread that is
    calling it is *not* the same as the thread that it is running
    on, and in this case adds the deallocs to a list (atomic) which 
    is processed inside the allocator update.

    Alternatively, received messages could just have a policy
    that they will be deleted on the next update. Don't hold
    on to them.

    Same for blocks, potentially.

    ----------------

    Add counters for all the different things inside the large blocks,
    eg. # of large blocks sent, received, read/written, also # of
    fragments read/written.

    Write some basic tests to verify these counters are functional.

    ------------------

    Might be nice to add a validate step to the config for connection/channels
    because it's possible to specify a config that doesn't work now. eg. 
    interdependent parameters.

    Would be nice if the reliable message channel could report the minimal functional
    budget that would work for it, given its configuration. This would be great
    for the connection to budget for the channel.

    This should be in the base class for channel interface, so we can generically
    work with and budget channels decently without knowing exactly what they are.

    ----------------------

    Move the channel budget out of the channel config (static)
    and in to the connection. 

    Channel budget should be dynamic. The user should be able to derive their own 
    connection type and specify channel budgets dynamically based on flow control, 
    for example.

    ---------------------

    Implement packet encryption via key, plus hash to detect tampering (unified). Optional feature.

    ---------------------

    Implement an unreliable channel (messages), 
    eg. queue up unreliable messages to send and discard any that don't fit in the packet.
    Bonus: Provide an optional functor to sort the unreliable messages in order of importance.

    ----------------

    Learn how to use chef/knife to setup the linux server properly with all
    the stuff I want automatically, vs. manually configuring it. eg. git,
    GCC and all that.

    Get the server loop setup properly. Server needs to update game and then sleep
    until time has elapsed for next frame. I think I have this code available
    from previous projects. Resurrect it.

    Find a nifty way with scripts to update the server on request, or automatically
    when git is checked in.

    Get the client/server workflow really tight!

    ------------------------------
