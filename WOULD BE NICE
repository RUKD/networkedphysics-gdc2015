WOULD BE NICE:

    Its really annoying when doing client work to not be able to build and 
    iterate on the C++ file without dropping to command line because of #ifdef CLIENT

    ----------------------

    It's really annoying to refer to protocol::memory, protocol::hash::something
    and so on. The basic functionality that protocol refers on should be called
    "core", eg. "core::memory", "core::hash" and so on.

    -----------------------------------

    Might be possible to hash packet with client/server guid + packet data,
    and then the overhead for the packet would become the hash, not the 
    client/server guid combination -- which is cool!

    -------------------------------

    I would like a small block of data (smaller than one packet) 
    that could be included with the client connection request,
    and with the server connection accepted.

    This would provide a way for subclassed client and server to
    extend the protocol and pass data up/down at initial point
    of connect, this is necessary functionality as integrations
    will probably want to extend connect with custom logic and data.

    -------------------------------

    Will probably remove the "CLIENT_SERVER" prefix, they are just packets.

    Packets may not always be used as part of client server. Packets are generic.

    -----------------------------

    Should probably move resolver tests out of unit tests, and create a new "test_resolver"

    It is too slow (in terms of real time), to run amongst the other tests.

    -----------------------------

    Would be nice to create an address by string, and then have a port override arg

    ----------------------

    Clean up the resolver so that it doesn't perform dynamic allocations.

    Find a way to move the future into the implementation (cpp)
    so we don't need #include <future> in a header file.

    Remove std::string usage from Resolver interface and DNSResolver.

    ----------------------

    Should be able to determine if scratch allocator is being exhausted,
    and falling back to malloc, eg. add a check, and then check this once
    per-frame inside the soak test -- i definitely *dont* want the scratch
    falling back to malloc inside soak test.

    Alternatively, add a flag so it asserts if it has to fallback to scratch,
    but disable this by default because otherwise it won't pass the unit test.

    -------------

    I would like the scratch allocator to be more resilient in  debug builds, 
    eg. for it to have safety checks, eg. missing magic # where expected, assert.

    --------------------

    I don't like the bool ipv6. Use address type instead, eg. ADDRESS_IPV6

    --------------------

    Restructure so that precompiled headers are used.

    Add timing to build steps so the efficiency can be measured.

    ----------------------

    Google have some cool allocators. Check them out.

    ----------------------

    Add some macros to make defining serialization and messages easier.

    ----------------------

    Basic logging. Just start with a "Log" macro that can be redirected
    to a "Logger" interface via virtual fn. 

    Of course, this is disabled in release build (NDEBUG) but it is 
    the easiest way to make sure the library can output logs to the
    appropriate place (console, TTY, file, whatever...)

    Should logs include the "\n" at the end?

    It would be nice if they didn't have to. It's easy to forget.

    --------------------

    Optimization for fragments, track oldest unacked fragment id, and start there
    and go left to right to search for fragments to send.

    --------------------

    Add a new fragmentSendWindow config, eg. 64 and only look this far past
    the oldest unacked fragment. Should save unnecessary scans for large block
    sizes.

    --------------------

    Could save a bit of memory and maybe gain some speed by switching 
    the received fragment data to a bitfield

    We only need one bit per-fragment, "has it been received?"

    ----------------

    Idea for logging, have an enum of channels, and per-channel a level integer
    Initial level is zero. Enable logging by setting the level. Per-channel logs
    can be emitted by passing the level, which defaults to 1.

    Log( "hello everybody %d\n", value );

    On a per-file basis, specify the current log channel via #define

    This may require the project gets split up into cpp files first.

    ----------------

    For the message and block allocator, I'm thinking of a thread
    local storage allocator that detects when the thread that is
    calling it is *not* the same as the thread that it is running
    on, and in this case adds the deallocs to a list (atomic) which 
    is processed inside the allocator update.

    Alternatively, received messages could just have a policy
    that they will be deleted on the next update. Don't hold
    on to them.

    Same for blocks, potentially.

    ----------------

    Add counters for all the different things inside the large blocks,
    eg. # of large blocks sent, received, read/written, also # of
    fragments read/written.

    Write some basic tests to verify these counters are functional.

    ------------------

    Might be nice to add a validate step to the config for connection/channels
    because it's possible to specify a config that doesn't work now. eg. 
    interdependent parameters.

    Would be nice if the reliable message channel could report the minimal functional
    budget that would work for it, given its configuration. This would be great
    for the connection to budget for the channel.

    This should be in the base class for channel interface, so we can generically
    work with and budget channels decently without knowing exactly what they are.

    ----------------------

    Move the channel budget out of the channel config (static)
    and in to the connection. 

    Channel budget should be dynamic. The user should be able to derive their own 
    connection type and specify channel budgets dynamically based on flow control, 
    for example.

    ---------------------

    Implement packet encryption via key, plus hash to detect tampering (unified). Optional feature.

    ---------------------

    Implement an unreliable channel (messages), 
    eg. queue up unreliable messages to send and discard any that don't fit in the packet.
    Bonus: Provide an optional functor to sort the unreliable messages in order of importance.

    ----------------
