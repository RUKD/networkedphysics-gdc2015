/*
    Network Protocol Foundation Library.
    Copyright (c) 2014, The Network Protocol Company, Inc.
*/

#ifndef PROTOCOL_SERVER_H
#define PROTOCOL_SERVER_H

#include "Packets.h"
#include "Connection.h"
#include "NetworkInterface.h"

namespace protocol
{
    class Allocator;

    struct ServerConfig
    {
        Allocator * allocator = nullptr;                        // allocator used for allocations that match the life cycle of this object. if null then default allocator is used.

        int maxClients = 16;                                    // max number of clients supported by this server.

        float connectingSendRate = 10;                          // packets to send per-second while a client slot is connecting.
        float connectedSendRate = 30;                           // packets to send per-second once a client is connected.

        float connectingTimeOut = 5.0f;                         // timeout in seconds while a client is connecting
        float connectedTimeOut = 10.0f;                         // timeout in seconds once a client is connected

        NetworkInterface * networkInterface = nullptr;          // network interface used to send and receive packets
        ChannelStructure * channelStructure = nullptr;          // defines the connection channel structure
        
        Block * serverData = nullptr;                           // server data sent to clients on connect. must be constant. this block is not owned by us (we don't destroy it)
        int maxClientDataSize = 64 * 1024;                      // maximum size for data received from client on connect. if the server data is larger than this then the connect will fail.
        int fragmentSize = 1024;                                // send server data in 1k fragments by default. good size given that MTU is typically 1200 bytes.
        int fragmentsPerSecond = 60;                            // number of fragment packets to send per-second. set pretty high because we want the data to get across quickly.
    };

    class Server
    {
        // todo: may want to do a hot/cold split for fast O(n) lookup of client data
        // per-client data structure below is getting a bit large -- eg. ClientIndexData

        struct ClientData
        {
            Address address;                                        // the client address that started this connection.
            double accumulator;                                     // accumulator used to determine when to send next packet.
            double lastPacketTime;                                  // time at which the last valid packet was received from the client. used for timeouts.
            uint64_t clientGuid;                                    // the client guid generated by the client and sent to us via connect request.
            uint64_t serverGuid;                                    // the server guid generated randomly on connection request unique to this client.
            ServerClientState state;                                // the current state of this client slot.
            Connection * connection;                                // connection object, once in SERVER_CLIENT_Connected state this becomes active.
            int fragmentIndex;                                      // current fragment that is being processed. search for next fragment to send starts here.
            int numFragments;                                       // number of fragments allocated in "ackedFragment"  array. used for clearing.
            int numAckedFragments;                                  // number of acked fragments. used to detect when the block has been fully transferred.
            double lastFragmentSendTime;                            // time that a fragment was last sent. used enforce fragments per-second in config.
            uint8_t * ackedFragment;                                // entry n is true if fragment n is server block has been acked.
            bool readyForConnection;                                // set to true once the client is ready for a connection to start, eg. client has sent their client data across (if any)
            int clientDataSize;                                     // client data size in bytes
            uint8_t * clientData;                                   // client data pointer
            Block clientDataBlock;

            ClientData()
            {
                connection = nullptr;
                ackedFragment = nullptr;
                clientData = nullptr;
                numFragments = 0;
                Clear();
            }

            void Clear()
            {
                accumulator = 0;
                lastPacketTime = 0;
                clientGuid = 0;
                serverGuid = 0;
                state = SERVER_CLIENT_STATE_DISCONNECTED;
                fragmentIndex = 0;
                lastFragmentSendTime = 0.0;
                numAckedFragments = 0;
                readyForConnection = false;
                if ( ackedFragment )
                    memset( ackedFragment, 0, numFragments );
                clientDataSize = 0;
                clientDataBlock.Disconnect();
            }

            ~ClientData()
            {
                PROTOCOL_ASSERT( ackedFragment == nullptr );
                PROTOCOL_ASSERT( clientData == nullptr );
            }
        };

        const ServerConfig m_config;

        Allocator * m_allocator;

        TimeBase m_timeBase;

        bool m_open = true;

        int m_numClients = 0;
        ClientData * m_clients = nullptr;

        PacketFactory * m_packetFactory = nullptr;                  // important: we don't own this pointer. it comes from the network interface

        int m_numServerDataFragments = 0;

    public:

        Server( const ServerConfig & config );

        ~Server();

        void Open();

        void Close();

        bool IsOpen() const;

        void Update( const TimeBase & timeBase );

        void DisconnectClient( int clientIndex );

        ServerClientState GetClientState( int clientIndex ) const;

        Connection * GetClientConnection( int clientIndex );

        const Block * GetClientData( int clientIndex ) const;

    protected:

        void UpdateClients();

        void UpdateSendingChallenge( int clientIndex );

        void UpdateSendingServerData( int clientIndex );

        void UpdateReadyForConnection( int clientIndex );

        void UpdateConnected( int clientIndex );

        void UpdateTimeouts( int clientIndex );

        void UpdateNetworkInterface();

        void UpdateReceivePackets();

        void ProcessConnectionRequestPacket( ConnectionRequestPacket * packet );

        void ProcessChallengeResponsePacket( ChallengeResponsePacket * packet );

        void ProcessReadyForConnectionPacket( ReadyForConnectionPacket * packet );

        void ProcessDisconnectedPacket( DisconnectedPacket * packet );

        void ProcessDataBlockFragmentAckPacket( DataBlockFragmentAckPacket * packet );

        void ProcessConnectionPacket( ConnectionPacket * packet );

        int FindClientIndex( const Address & address ) const;

        int FindClientIndex( const Address & address, uint64_t clientGuid ) const;

        int FindFreeClientSlot() const;

        void ResetClientSlot( int clientIndex );
    };
}

#endif
