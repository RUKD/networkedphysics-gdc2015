/*
    Network Protocol Library
    Copyright (c) 2013-2014 Glenn Fiedler <glenn.fiedler@gmail.com>
*/

#ifndef PROTOCOL_SERVER_H
#define PROTOCOL_SERVER_H

#include "Connection.h"
#include "NetworkInterface.h"
#include "ClientServerPackets.h"

namespace protocol
{
    enum ConnectionRequestDenyReason
    {
        CONNECTION_REQUEST_DENIED_ServerClosed,                 // server is closed. all connection requests are denied.
        CONNECTION_REQUEST_DENIED_ServerFull,                   // server is full. no free slots for a connecting client.
    };

    enum ServerClientState
    {
        SERVER_CLIENT_Disconnected,                             // client is disconnected. default state.
        SERVER_CLIENT_SendingChallenge,                         // responding with connection challenge waiting for challenge response
        SERVER_CLIENT_SendingDataBlock,                         // sending data block to client
        SERVER_CLIENT_ReceivingDataBlock,                       // receiving data block from client
        SERVER_CLIENT_Connected                                 // client is fully connected. connection packets are now exchanged.
    };

    struct ServerClientData
    {
        Address address;                                        // the client address that started this connection.
        uint64_t clientGuid;                                    // the client guid generated by the client and sent to us via connect request.
        uint64_t serverGuid;                                    // the server guid generated randomly on connection request unique to this client.
        ServerClientState state;                                // the current state of this client slot.
        shared_ptr<Connection> connection;                      // connection object, once in SERVER_CLIENT_Connected state this becomes active.
    };

    struct ServerConfig
    {
        uint64_t protocolId = 42;                               // the protocol id. must be the same for client and server to talk.

        int numClients = 32;                                    // number of clients supported by this server.

        // todo: various timeouts and send rates per-server client state
        
        shared_ptr<NetworkInterface> networkInterface;          // network interface used to send and receive packets

        shared_ptr<ChannelStructure> channelStructure;          // defines the connection channel structure
    };

    class Server
    {
        const ServerConfig m_config;

        TimeBase m_timeBase;

        bool m_open = true;

        vector<ServerClientData> m_clients;

    public:

        Server( const ServerConfig & config )
            : m_config( config )
        {
            assert( m_config.networkInterface );
            assert( m_config.channelStructure );
            assert( m_config.numClients >= 1 );

//            cout << "creating server with " << m_config.numClients << " clients slots" << endl;

            m_clients.resize( m_config.numClients );
        }

        void Open()
        {
            m_open = true;
        }

        void Close()
        {
            m_open = false;
        }

        bool IsOpen() const
        {
            return m_open;
        }

        void Update( const TimeBase & timeBase )
        {
            m_timeBase = timeBase;

            UpdateClients();

            UpdateNetworkInterface();

            UpdateReceivePackets();
        }

    protected:

        void UpdateClients()
        {
            for ( int clientIndex = 0; clientIndex < m_clients.size(); ++clientIndex )
            {
                switch ( m_clients[clientIndex].state )
                {
                    case SERVER_CLIENT_SendingChallenge: 
                        UpdateSendingChallenge( clientIndex );
                        break;

                    case SERVER_CLIENT_SendingDataBlock:
                        UpdateSendingDataBlock( clientIndex );
                        break;

                    case SERVER_CLIENT_ReceivingDataBlock:
                        UpdateReceivingDataBlock( clientIndex );
                        break;

                    case SERVER_CLIENT_Connected:
                        UpdateConnected( clientIndex );
                        break;

                    default:
                        break;
                }
            }
        }

        void UpdateSendingChallenge( int clientIndex )
        {
            ServerClientData & client = m_clients[clientIndex];

            assert( client.state == SERVER_CLIENT_SendingChallenge );

            // ...
        }

        void UpdateSendingDataBlock( int clientIndex )
        {
            ServerClientData & client = m_clients[clientIndex];

            assert( client.state == SERVER_CLIENT_SendingDataBlock );

            // ...
        }

        void UpdateReceivingDataBlock( int clientIndex )
        {
            ServerClientData & client = m_clients[clientIndex];

            assert( client.state == SERVER_CLIENT_ReceivingDataBlock );

            // ...
        }

        void UpdateConnected( int clientIndex )
        {
            ServerClientData & client = m_clients[clientIndex];

            assert( client.state == SERVER_CLIENT_Connected );

            // ...
        }

        void UpdateNetworkInterface()
        {
            m_config.networkInterface->Update( m_timeBase );
        }

        void UpdateReceivePackets()
        {
            while ( true )
            {
                auto packet = m_config.networkInterface->ReceivePacket();
                if ( !packet )
                    break;

//                cout << "server received packet" << endl;

                switch ( packet->GetType() )
                {
                    case PACKET_ConnectionRequest:
                    {
                        auto connectionRequestPacket = static_pointer_cast<ConnectionChallengePacket>( packet );

//                        cout << "server received connection request packet" << endl;

                        if ( !m_open )
                        {
//                            cout << "server is closed. denying connection request" << endl;

                            auto connectionDeniedPacket = make_shared<ConnectionDeniedPacket>();
                            connectionDeniedPacket->protocolId = m_config.protocolId;
                            connectionDeniedPacket->clientGuid = connectionRequestPacket->clientGuid;
                            connectionDeniedPacket->reason = CONNECTION_REQUEST_DENIED_ServerClosed;

                            m_config.networkInterface->SendPacket( packet->GetAddress(), connectionDeniedPacket );
                        }
                    }
                    break;

                    default:
                        break;
                }
            }
        }
    };
}

#endif
