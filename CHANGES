Sunday March 16th, 2014:
------------------------

    Add sent packets to the sliding window

    Add received packets to the sliding window

    Extend sliding window to return false if packet is too old
    to add to sliding window, eg. discard packet

    Properly implement "sequence_less_than" and "sequence_greater_than" functions, 
    and test that they correctly handle 16 bit wrap around.

    Fixed bug in sliding window. Uninitialized data in ctor.

    Detect if received packet is too old to add to sliding window. Discard packet.

    Implement "GenerateAckBits" function.

    Unit test the generate ack bits function (it should basically take a sliding window and return ack, ack_bits)

    Yep. It was slightly off with or then shift. needed to be shift then or.

    Implement the "ProcessAcks" function to take ack + ack_bits and check for sent packets matching,
    call "PacketAcked" if it is the first time a sent packet with that sequence was acked.

    Add counters and include basics stats such as number of packets writter, read, acked, discarded.

    Extend unit test to verify counters match expected results, eg. acks especially.


Saturday March 15th, 2014:
--------------------------

    Should there be nodes? Yes. But strictly client/server. No support for P2P.

    This means there is just the server, with data per-client, and the client's
    view of the server data that is synchronized to it.

    So calling each connection a "client" instead of a node is probably correct.

    But a node is more generic, and it makes sense for a server to have n nodes,
    one per-client, but on the client to just have one node.

    Alternatively, it could be called "connection"?

    Yes. Going with connection. I can then later on create a server class
    with one connection per-client, and a client class with a single connection
    to the server. SORTED.

    Sketched out connection packet with sequence, ack, ack_bits.

    Sketched out functions and data structures required to implement reliability.

    Implement sliding window class.

    Maybe consider moving the sequence numbers, eg. most recent sent packet, most recent received *into* the sliding window.

    Maybe add a bool into sliding window, eg. have you ever had an entry inserted yet? (eg. for initial sliding window set sequence)

    Yes. Everything becomes simple if the sliding window class is well designed like this...

    Sliding window is basic. But it seems additional logic is required, like how to 
    detect if a received packet is in the window. Discarding of old packets etc.

    This logic I think is specific to the send and receive sliding windows.

    I will keep it out of the sliding window class.

    Unit test the sliding window class.


Friday March 14th, 2014:
------------------------

    Get the network interface working across IPv6 too ("::1")

    Now adjust so you can create the network interface in IPv4 mode or IPv6 mode.

    Currently using AF_INET to mean IPv4, AF_INET6 to mean IPv6 only and
    AF_UNSPEC to mean dual stack. This may not be the best.

    Do I care about dual stack at this point? No I don't. Cut dual stack support.

    Add query fn to get maximum packet type from factory. Necessary for serialization.


Wednesday March 12th, 2014:
---------------------------

    Add test to verify send and receive packet by address.

    Create non-blocking socket inside network interface.    

    Clean up socket in network interface dtor.

    Fixed address initialize from addrinfo to include port.

    Hack up the sendto to work with IPv6 address types.

    Added comparison operators to packets and learned about static_pointer_cast.

    Added code to verify the packets received on the other side verify the 
    packets that were sent, before serialize read and write.

    Hacked up a really nasty serialize write buffer for stream. I'll fix this up later.

    Implemented internal packet send code that calls through to sendto with
    serialize write buffer contents.

    Need a config to pass into the network interface, we'll need to specify
    the maximum packet size in there, otherwise we're going to not know
    what size buffer to use for recvfrom.

    Need to pass factory into network interface. It needs it so it knows
    what the maximum packet type is (for serialize).

    Added network interface config. config specifies max packet size,
    packet factory, dns resolver (optional) and UDP port to bind to.

    Call recvfrom and get packet data. 

    Some problem where recvfrom is always returning -1. Possible that my address is wrong
    and it is always WSAWOULDBLOCK? Need to dig in and get socket error in this case.

    Address int32 was double converted using htonl. Fixed.

    Serialize read this buffer into a stream and then determine the packet type.

    Create an object of the correct type. If packet for type cannot be created, 
    increment a counter and discard the packet.

    Serialize the packet. If the packet serialize fails discard the packet
    and increment serialize read failure counter.

    If the packet serializes properly, add the packet to the receive queue


Sunday March 9th, 2014:
-----------------------

    Implement lookup from hostname to address inside network interface via resolver

    Added counters to network interface to aid in unit tests (eg. num packets sent, received, discarded)

    Add test to verify hostname lookup + resolve send queue + send on resolve works

    Add test to verify hostname failure discards packets

    Carry the port # from send to address -> internal send queue (resolve). Verify with logs.


Tuesday March 5th, 2014:
------------------------

    Need a way to resolve DNS into addresses.

    Add a new interface "Resolver". 

    Derive from this and create a new "DNSResolver"

    This will keep it generic, for example I could create redis
    based server resolver for giving game instances server names,
    or a master server list etc.

    By having a resolver interface I won't care how the name -> address
    resolution occurs, just that it *does* occur.

    Added way to initialize address from addrinfo ptr (from resolve DNS...)

    Cache data on lookup so it can be queried.

    If an address has already been looked up, don't fire off a new async for it.
    (but must you call the callback?! not sure... probably.)

    There should have the option to clear the cache.

    There should be a way to look up an address without calling lambda.

    Optimize DNS resolver so that in-progress queries are in a separate hash,
    so we don't go O(n) in the udptae after lots of queries have been done.

    Verify that multiple overlapping resolve calls work, and all the lambdas are called on completion

    Verify resolve failure works as well, and cached fail result.


Sunday March 2nd, 2014:
-----------------------

    Basic serialization, serialize_int etc.

    Base object for serialization with virtual Serialize( Stream & stream ) method.

    Back packet class with serialize, address string (eg. sent from), and type int.

    Factory class to create packets from type.

    If you try to create an object of a type that is not registered, throw a runtime_error.

    Explore "getaddrinfo" for IPv6 aware hostname -> IP address etc.

    Implement basic address class capable of handling IPv6 and IPv6

    Implement function to convert IPv4 string to address int + port

    Verify IPv4 UDP broadcast address is converted properly: 0xffffffff

    Implement function to convert IPv4 address + port back to string
    (Omit the port if it is zero).

    Added code to initialize IPv6 with 16bit pairs, including htons
    (decided on network byte order for internal address data...)

    Handle port number in IPv6 output string, eg. "[v6addr]:portnum"

    Implement IPv6 parse from string

    Implement IPv6 parse from string with port, eg. "[addr6]:portnum"
