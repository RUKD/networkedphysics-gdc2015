NOTES

------------------------

I want to start with a pure/client server model

eg. the server sends inputs to the server and the server runs all simulation.

Server sends snapshots to the client which are interpolated for rendering.

This is the correct way to start, client side prediction can be added later.

This will allow me to implement:

    a) entity system

    b) send tables per-entity

    c) snapshots

    d) delta encoding

I propose the cube demo as a starting point.

This will allow me to quickly get a client setup and pare it down 

(eg. remove the circle of relevancy concept, we don't need it, yet...)

Goal: Get the cube demo synchronized entirely from server -> client
while having the flexibility to run the game in an integrated server
or true client and dedicated server mode.

From this drive all further development of the protocol library.

------------------------

Implement fragmentation and reassembly for large packets, do this
at the connection level once we have large snapshots, this would
probably be a good idea to have -- set MTU to 1200 bytes.

Keep it simple. A packet is received when all its fragments
have been received. If any of the fragments are dropped,
then the packet is dropped.

I propose a simple header, eg. a packet type for fragment packet
with a header x/y fragments and the sequence number of the *unacked*
packet.

Then the complexity becomes:

a) writing the fragments, and not sending them out too rapidly
b) on the receive side collating the fragments and reassembling them.

------------------------

Where does fragmentation and reassembly live?

Ideally, I would like for it to be in the connection layer
or at least somewhere that it doesn't need to be implemented
from scratch with each different network interface implementation.

Is this possible?

Maybe it should just be at the interface level.

------------------------

Integrate LZ compressor for compressing large blocks, and for compressing
initial block sent down to client.

Ideally, LZ4 could be something enabled via config that is used, if it exists
this way it is up to the user of the library to ensure they have LZ4 installed.

I don't want to manage the LZ4 library includes/libs inside my library,
if I can avoid it.

It might be a good idea to see if LZ4 can compress typical packets sent as well,
for example, put a bit in the header indicating that the packet is compressed,
if LZ4 is enabled, and then decode the packet via LZ4.

This would have to live at the network interface level, presumably.

Potentially set a minimum packet size or block size for LZ compression,
and even then, check if the compressed packet/block is larger than uncompressed
and send uncompressed instead.

Per-packet or block (large block), we would need a bit indicating if compressed.

------------------------

-------------------------

What would the packet structure look like for packets supporting MTU split?

I think there would be a one byte header for packets.

This packet could start with two flags, 0 by default:

    + compressed packet 
    + fragmented packet

If this first byte is zero, then the packet data follows immediately.

If it is non-zero, then special treatment is required.

If the packet is fragmented, then it is followed with:

    16 bit fragment id
    16 bit num fragments 

If we set MTU to 1200 bytes, then we should walk through a packet
larger than that, and take 1200 - 5 = 1195 bytes at a time, this 
gives enough room for the header.

This means that we should prefix packets written with 5 padding bytes.

This way if we discover that a packet needs to be split across MTU
we can use these prefix bytes to write the header for each packet
and write them in turn. 

It destroys the buffer as written, but it's use once only so no problem.

------------------------

So a question -- do we really need to be concerned about the performance
when fragmenting packets. Fragmenting packets should be rare, eg. only
ever done when we're sending down a bit block.

------------------------

OK so do I *really* need to implement fragmentation and reassembly
of packets. I have large block fragmentation and reassembly inside
messages.

If I implemented instead a fragmentation and reassembly of a large
unreliable block message, or something specific to snapshots, eg.
send down a large snapshot and split that across two packets, eg.
emit two packets instead of the normal one.

------------------------

How to efficiently send a packet that is larger than MTU without copying?

Easy. Prefixing a packet with enough bytes before writing such that there
are unused bytes in front that can be filled if the serialize goes over MTU.

This way I can then strip through the packet across MTU size

-----------------------

What is the next most important thing?

I feel that it is the context and perhaps a higher level
"GameClient" and "GameServer" interface that wraps up a
lot of a overly complicated stuff into a clean interface.

I feel like a lot of the low-level stuff that I have created
is like a build your own protocol toolkit, but I think that
in reality it is a much too low-level for actual integration
into a game.

I think the game is going to want a nice way to define messages.

A nicer way to create them, and send them.

On the server a nice way to send messages reliably or unreliably,
and to specify who the messages should be sent to (broadcast,
or to everybody...)

------------------------

I think perhaps maybe the best thing to do at this point would 
be to step back and design the ideal interface at the game level.

eg. GameServer/GameClient

Determine what callbacks the game server / game client wants

The game server and client probably don't give a shit about
the packet channel structure. Really only care about defining
set of message types, and having a nice interface to send and recv.

-------------------------

Right now the interface for sending and receiving messages is terrible.

The interface for specifying message types is terrible.

The creation is *OK*

The release is *OK*

-------------------------

I think in order for game server / client to function properly,
to have a good interface, they have to assume a certain packet structure.

-------------------------

Should I simplify the current client/server so that they have assumed
packet structure, or wrap another class around them?

-------------------------

I really dislike the idea of having two different client/server class types.

-------------------------

I think this means that client/server should have a predefined channel structure.

-------------------------

Should implement unreliable message channel.

-------------------------

Need to get started on snapshots and so on.

-------------------------

Need MTU handling to do snapshots (can be large)

-------------------------

Need sendtables to do snapshots

Need context to do snapshots...

-----------------------------------------

How will multithreading work with the networking?

It's probably wise to start exploring this.

Any good networking solution needs to at minimum run the bulk of work off the main thread.

Perhaps the game client / game server represent the main thread interface to the parallel
stuff running in the back-end, that is more low-level.

eg. the game client / game server interface is just the front-end that interfaces
with the real networking stuff running in a parallel thread.

It should then really just be a bunch of queues...

-----------------------------------------

Client and server should be designed to be *Extendable*

My guess is that integration into the game will require
deriving your own client and server classes from the base.

-------------------------------------------------------------------------------------------------------------

Analysis of existing protocol serialization layers.

Cap'n Proto looks a bit overengineered (eg. second systems effect)

MessagePack looks a bit smaller and tight to me, but probably less efficient
over the wire and in terms of packing time.

Are protocol buffers worth integrating?

Google snappy looks like a nice candidate for message compression

Is there a nice library for message encryption between servers over UDP?
(eg. a shared secret is fine, server code is not distributed)

Nettle library looks OK. Does google have a library that they use?

On write:

    serialize write -> compress -> encrypt -> sign -> send

On read:

    recv -> verify signature -> decrypt -> serialize read

If I have my own reliable ordered block channel, I can then derive
specific channels from that, eg. JSONChannel, CapnProtoChannel,
MsgPackChannel, ThriftChannel and so on... should be easy to add
additional libraries and try them out. Try them all! :D

-------------------------------------------------------------------------------------------------------------

When sending a message, it should be up to the runtime to decide how to send it.

I have seen flexibility in systems at work that allow the game code to decide
whether something is reliable or not at runtime depending on context.

Do not assign "reliable" or "unreliable" to a message type statically at definition.

------------------------------------------------------------------------------------------------------------

What do I want my library to achieve?

    0. It should provide platform independent UDP abstraction over IPv4 and IPv6 (done)

    1. It should be suitable for both ad-hoc unreliable UDP messages and connection
       oriented protocol over UDP between client and server (done)

    2. It should operate over UDP and have reliability built in with ack bits (done)

    4. It should support bit-packing (done)

    5. It should be designed to work well with LZ dictionary based compression (done)

    6. It should be extremely fast, eg. low CPU cost for packet read and write (done)

    7. It should support send tables, entities, snapshots, delta encoding, interpolation and client side prediction (in progress)

------------------------------------------------------------------------------------------------------------
