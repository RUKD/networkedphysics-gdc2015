NOTES

-----------------------

What is the next most important thing?

I feel that it is the context and perhaps a higher level
"GameClient" and "GameServer" interface that wraps up a
lot of a overly complicated stuff into a clean interface.

I feel like a lot of the low-level stuff that I have created
is like a build your own protocol toolkit, but I think that
in reality it is a much too low-level for actual integration
into a game.

I think the game is going to want a nice way to define messages.

A nicer way to create them, and send them.

On the server a nice way to send messages reliably or unreliably,
and to specify who the messages should be sent to (broadcast,
or to everybody...)

------------------------

I think perhaps maybe the best thing to do at this point would 
be to step back and design the ideal interface at the game level.

eg. GameServer/GameClient

Determine what callbacks the game server / game client wants

The game server and client probably don't give a shit about
the packet channel structure. Really only care about defining
set of message types, and having a nice interface to send and recv.

-------------------------

Right now the interface for sending and receiving messages is terrible.

The interface for specifying message types is terrible.

The creation is *OK*

The release is *OK*

-------------------------

I think in order for game server / client to function properly,
to have a good interface, they have to assume a certain packet structure.

-------------------------

Should I simplify the current client/server so that they have assumed
packet structure, or wrap another class around them?

-------------------------

I really dislike the idea of having two different client/server class types.

-------------------------

I think this means that client/server should have a predefined channel structure.

-------------------------

Should implement unreliable message channel.

-------------------------

Need to get started on snapshots and so on.

-------------------------

Need MTU handling to do snapshots (can be large)

-------------------------

Need sendtables to do snapshots

Need context to do snapshots...

-----------------------------------------

How will multithreading work with the networking?

It's probably wise to start exploring this.

Any good networking solution needs to at minimum run the bulk of work off the main thread.

Perhaps the game client / game server represent the main thread interface to the parallel
stuff running in the back-end, that is more low-level.

eg. the game client / game server interface is just the front-end that interfaces
with the real networking stuff running in a parallel thread.

It should then really just be a bunch of queues...

-----------------------------------------

Client and server should be designed to be *Extendable*

My guess is that integration into the game will require
deriving your own client and server classes from the base.

-------------------------------------------------------------------------------------------------------------

Analysis of existing protocol serialization layers.

Cap'n Proto looks a bit overengineered (eg. second systems effect)

MessagePack looks a bit smaller and tight to me, but probably less efficient
over the wire and in terms of packing time.

Are protocol buffers worth integrating?

Google snappy looks like a nice candidate for message compression

Is there a nice library for message encryption between servers over UDP?
(eg. a shared secret is fine, server code is not distributed)

Nettle library looks OK. Does google have a library that they use?

On write:

    serialize write -> compress -> encrypt -> sign -> send

On read:

    recv -> verify signature -> decrypt -> serialize read

If I have my own reliable ordered block channel, I can then derive
specific channels from that, eg. JSONChannel, CapnProtoChannel,
MsgPackChannel, ThriftChannel and so on... should be easy to add
additional libraries and try them out. Try them all! :D

-------------------------------------------------------------------------------------------------------------

When sending a message, it should be up to the runtime to decide how to send it.

I have seen flexibility in systems at work that allow the game code to decide
whether something is reliable or not at runtime depending on context.

Do not assign "reliable" or "unreliable" to a message type statically at definition.

------------------------------------------------------------------------------------------------------------

What do I want my library to achieve?

    0. It should provide platform independent UDP abstraction over IPv4 and IPv6 (done)

    1. It should be suitable for both ad-hoc unreliable UDP messages and connection
       oriented protocol over UDP between client and server (done)

    2. It should operate over UDP and have reliability built in with ack bits (done)

    4. It should support bit-packing (done)

    5. It should be designed to work well with LZ dictionary based compression (done)

    6. It should be extremely fast, eg. low CPU cost for packet read and write (done)

    7. It should support send tables, entities, snapshots, delta encoding, interpolation and client side prediction (in progress)

------------------------------------------------------------------------------------------------------------
