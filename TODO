DONE:

TODO:

    Should there be nodes? Yes. But strictly client/server. No support for P2P.

    This means there is just the server, with data per-client, and the client's
    view of the server data that is synchronized to it.

    So calling each connection a "client" instead of a node is probably correct.

    But a node is more generic, and it makes sense for a server to have n nodes,
    one per-client, but on the client to just have one node.

    Alternatively, it could be called "connection"?

    ----

    Implement connection protocol. This should basically be a new packet type "ConnectionPacket"
    which internally allows me to implement the reliability header, reliable messages w. channels
    and so on.

    Key difference here is that messages should be arbitrary length (short or long) and should
    be fragmented and reassembled as needed to fit in the packet, vs. previous systems where I
    have treated small (events) and large (chunks) separately.

    Basic idea is a reliable-ordered protocol with flexible messages of any size, plus channels
    so I can avoid waiting for long blocks of data if I don't wish to, plus unreliable-unordered
    state messages, and potentially delta encoding.

    Connection should be flexible enough to define your own paylod as well.

INTERNET READY:

    Implement proper range encoder. Don't do a bitpacker this time that's already been done.

    Study how it works. Implement something that encodes and decodes in-place. Optimize for CPU later.

    Add encryption for packets, assuming that matchmaker will provide secret key, any fast key
    based encryption is acceptable. Do this at the network interface level, eg. network interface
    accepts a key. If the key is a non-empty string, apply the encrytion before send, and decrypt
    on recvfrom.

    Make sure there is some checksum or basic check for packets, eg. signing packets. tamper check.
    Reuse the same key for encryption if possible. Research this and study how it is done.

OPTIMIZATION:

    Optimize range encoder

    Send and receive queues should be lockless threadsafe

    Separate send and receive threads for NetworkInterface

    Investigate different methods for sending and receiving UDP packets,
    eg. completion ports on Win32, whatever method is fastest on linux etc.

    Run throughput tests with linux hosts. Test CPU usage etc.
