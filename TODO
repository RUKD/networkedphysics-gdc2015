DONE:

TODO:
    
    OPTIMIZE!!!

    --------------------

    Instead of walking the send queue to find the oldest message id not acked,
    cache this value, and on each update, walk left to right to skip past acked
    messages in the send queue to get the new value.

    --------------------

    Optimization for fragments, track oldest unacked fragment id, and start there
    and go left to right to search for fragments to send.

    --------------------

    Add a new fragmentSendWindow config, eg. 64 and only look this far past
    the oldest unacked fragment. Should save unnecessary scans for large block
    sizes.

    --------------------

    Bring back templated serialize functions.

    Yes, network object should have virtual SerializeRead( ReadStream & stream )
    and SerializeWrite functions, BUT... these can be implemented via templated 
    serialize fn in the class.

    I think this is the best of both worlds, and avoids any overhead in the
    serialize due to extra branching.

    --------------------

    Remove usage of cout and replace uniformly with printf. Fuck cout it's slow as shit.

    --------------------

    Remove "format_string" function.

    --------------------

    SoakTest seems to not work with -DNDEBUG. Why?

    --------------------

    I'd like a logging system. It's annoying to have to comment out and re-enable
    logs as I debug things. Would be nice to be able to enable/disable channels,
    and have virtually zero cost if a channel is disabled.

    Would be nice to have logs completely disabled in release build.

    Perhaps I could get an evaluation of deja. Maybe I can even get a licence
    if I write an article explaining my usage of deja? Contact the authors.

    But does deja have a mac UI client? Almost certainly not.

    --------------------










    ------------------------

    Add code on server to send server data block to client.

    Block must be *constant*. eg. add it as part of server config

    Server sends one block fragment per-packet. No need for complicated reliability.

    Client replies with a separate packet acking each fragment he sees. Nothing complicated.

    Server just keeps sending them until all acked.

    Once server has acks for every fragment, go into the requesting client block state.

    Client should store, and make the server data block accessible via accessor.

    Add unit test to verify it's working, make sure to check the block size and contents match.

    ------------------------

    Some thing in reverse for client -> server block.

    Once the block transfers have completed, go to connected state.

    Make client block accessible per-server, and make sure it is cleared when the client disconnects.

    Add test to verify server receives the correct size block and contents from the client.

    ------------------------

    Implement fragmentation and reassembly for large packets, do this
    at the connection level once we have large snapshots, this would
    probably be a good idea to have -- set MTU to 1200 bytes.

    Keep it simple. A packet is received when all its fragments
    have been received. If any of the fragments are dropped,
    then the packet is dropped.

    I propose a simple header, eg. a packet type for fragment packet
    with a header x/y fragments and the sequence number of the *unacked*
    packet.

    Then the complexity becomes:

    a) writing the fragments, and not sending them out too rapidly
    b) on the receive side collating the fragments and reassembling them.

    ------------------------






    *** SEND TABLES ***

    ---------------

    Implement send table concept. Implement delta encoding tables etc.

    Use the server data to communicate this table down to the client.

    ------------------------

    Actually implement a client/server setup and host the server in the cloud.

    Provide build steps using chef/knife or whatever to easily deploy this server.

    ------------------------









WOULD BE NICE:

    ----------------

    Add counters for all the different things inside the large blocks,
    eg. # of large blocks sent, received, read/written, also # of
    fragments read/written.

    Write some basic tests to verify these counters are functional.

    ------------------

    Might be nice to add a validate step to the config for connection/channels
    because it's possible to specify a config that doesn't work now. eg. 
    interdependent parameters.

    Would be nice if the reliable message channel could report the minimal functional
    budget that would work for it, given its configuration. This would be great
    for the connection to budget for the channel.

    This should be in the base class for channel interface, so we can generically
    work with and budget channels decently without knowing exactly what they are.

    ----------------------

    Move the channel budget out of the channel config (static)
    and in to the connection. 

    Channel budget should be dynamic. The user should be able to derive their own 
    connection type and specify channel budgets dynamically based on flow control, 
    for example.

    --------------------

    Optimize the block send and receive to not require a data copy or allocation
    for each fragment data block, use pointers and directly serialize in/out of
    block data instead.

    ^-- is this a significant overhead? I'm not sure it is. 

    But maybe for large fragment sizes.

    --------------------

    Could save a bit of memory by switching the received fragment data to a bitfield

    We only need one bit per-fragment, "has it been received?"

    ---------------------

    Integrate the oodle library. Provide an #if USE_OODLE 1 type thing and hook it up
    for compression. Try it out in the stress test and see how it generates dictionaries
    and how much compression it gets post-dictionary and so on. Do not check in the oodle
    libs, but do check in the interface and source code that uses it.

    ---------------------

    Implement packet encryption via key, plus hash to detect tampering (unified). Optional feature.

    ---------------------

    Implement an unreliable channel (messages), 
    eg. queue up unreliable messages to send and discard any that don't fit in the packet.
    Bonus: Provide an optional functor to sort the unreliable messages in order of importance.

    --------------------

    Implement an atomic queue on top of the client and server interface for sending
    and receiving user packets. This interface should allow running the actual serialization
    and packet reading entirely on a separate thread. Do it here where it is most natural,
    to avoid overcomplicating the interface/connection code.

    ----------------
