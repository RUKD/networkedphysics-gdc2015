DONE:

    Sketch out a shader to render the text. 

    Don't worry about lighting or coloring yet, just get the texture coord out there.

    Need to get the text working with proper projection matrix. Might be good to just
    keep it uniform, vs. having a specific text shader that only works in 2D space.

    Work out how to get the .r coordinate in for an alpha texture. Done.

TODO:

    Work out how to get a projection matrix for screenspace for the text.

    I think it's best to leave the text rendering general, eg. allow a matrix
    to be passed in, much like all other vertex shaders, for generality.

    Set this up and render some text with 1:1 texels 

    Make sure to offset the text by a small amount for the "diamond"
    rasterization rule so I can be guaranteed 1:1 mapping of texels
    to pixels.

    Implement vertex buffer generation (dynamic?) to render text quads.

    Text should now render and look GREAT (hires, and with correct gamma)

    Now try out a few different console fonts and pick out a good one.

    -------------------------------

    Work out how to manage debug rendering of text, eg. is there some
    debug manager that will handle rendering in order for debug triangles,
    lines etc, eg. batching drawcalls, or should i do it immediate?

    -------------------------------

    Clean up awful font loader code

    Clean up awful shader loader code

    Font should accept an allocator and do all allocations that way.

    It should use the temp allocator to create a temporary buffer
    for the image load and conversion step.

    ------------------------------

    Split out common stuff from protocol to "core"

    This should include types, allocators, common, log functions, file functions (from tools)
    and so on. Core should be accessible to all libraries, tools and executables, client and server.

    I'm thinking src/core, src/protocol and so on.

    This would avoid annoying stuff like protocol::hash::get and so on. Hash is not part of protocol!

    ------------------------------

    I would like a mesh manager

    ------------------------------

    I would like a texture manager (seems that OpenGL does most of this, but could make it a bit easier...)

    Meshes and textures should be able to be loaded on-demand and inserted into the managers

    Should not load *all* meshes and textures, only what is asked to be loaded.

    By tracking all the textures loaded, we can reload them as required, eg. reload textures.

    ------------------------------

    Texture manager should handle both loading textures from disk, mipmap or not.

    It should also handle dynamically generated textures, eg. the alpha font textures being created.

    Should font textures be piped through the texture manager? Probably for the best.

    But if a texture is dynamically loaded, then it cannot be reloaded via texture manager.

    Dynamically loaded/generated textures don't add a load of value being placed in the texture manager.

    Texture manager would be best for textures that are loaded and precached by name from disk.

    ------------------------------

    The stone data below should *refer* to the meshes and textures inside stone JSON definitions

    But should not define the stone mesh or texture itself!

    It is much more general to have meshes and textures being able to be loaded separately,
    referenced in by the stone, rather than having a custom solution for stone meshes and textures.

    ------------------------------

    Write a tool to generate go stone meshes.

    Tool should take JSON input to describe the stones, eg. width/height bevel, tesselation and such.

    Generate a bunch of different sizes, eg. all the standard sizes that can exist and make sure the stones are generated to a high resolution.

    Make sure the generation is fast. If it's not fast, optimize it (eg. optimize the code that calculates the )

    Make sure the go stone generation code doesn't do work if the meshes already exist.

    Consider generating a go stone binary format that can be loaded in, vs. generating the .obj file format.

    Make sure the loading of go stones is super fast. Should not require a great deal of work.

    eg. Generate a ".stone" file

    Load in a bunch of go stones.

    ------------------------------

    Write a tool to calculate the inertia tensor for a go stone.

    Just include this inside the stone definition, vs. calculating it on the fly, as this calculation can be slow.

    Hopefully it is not too slow to generate a bunch of stone meshes, but if it is, then it should be
    possible to generate the stone meshes offline, and just insert them into a "content" directory
    that is then crunched (from say, .obj format) to the in-game format (binary), .mesh

    This could be done at the time of copying the meshes from data directory, to bin/data, eg. "pm data"

    ------------------------------

    Explore physically based shading with go stones. I want a level that is an array 
    of go stones with varying physically based properties changing in a grid, like
    the typical physically based shading tests with spheres.

    Talk to Steve Marton at work to determine where to get started.

    ------------------------------

    Implement a quake style console.

    The console should have its own JSON file, eg. Console.json

    Inside this it should specify the fonts to be used by the console.

    The console should be capable of reloading its settings on the fly.

    Redirect stdout and stderr output to the console.

    Implement keyboard input to type text into this console.

    ------------------

    Implement some sort of key binding system, eg. bind a key to an action

    Use this key binding system to bind keys to pageup, pagedown, ctrl-up, ctrl-down
    and so on to control the console. Don't hardcode it!

    This probably requires implementing the concept of "FOCUS"

    eg. the game has focus, vs. the console having focus.

    We need a window manager or a focus manager or something. The game needs to have
    it's own interface on the client that implements input focus so it is passed
    inputs when the console doesn't have focus.

    ------------------

    Have console off by default (previous was on)

    Implement key binding "~" to toggle the console on off

    Implement escape to quit the game (maybe with yes/no prompt, with enter/escape as cancel?)

    Implement command history buffer, eg. up-down

    Implement scrolling in this console buffer, eg. page-up page-down, ctrl-up, ctrl-down,
    command-up, command-down.

    ------------------

    Implement console commands on client

    Implement quit console command, connect console command and disconnect.

    Should be able to connect to a server, disconnect from it, reconnect, then quit.

    ------------------

    Color the commands nicely so errors are colored, commands are colored,
    output from the game log is colored and so on.

    Put these color configurations inside config json files, eg. data/config/Console.json

    ------------------

    Add a log as well, output to client.log on server.log with append.

    Make sure that when a new instance of the program runs it puts a new
    header in there, or =========================== or something similar.

    ------------------

    Learn how to use chef/knife to setup the linux server properly with all
    the stuff I want automatically, vs. manually configuring it. eg. git,
    GCC and all that.

    Get the server loop setup properly. Server needs to update game and then sleep
    until time has elapsed for next frame. I think I have this code available
    from previous projects. Resurrect it.

    Find a nifty way with scripts to update the server on request, or automatically
    when git is checked in.

    Get the client/server workflow really tight!

    ------------------------------

    Add concept of console commands and console variables

    Hook up concept of client and server side console commands / convars

    Work out how to transmit these to the client on initial connect
    and then on each change.

    ------------------------------

NOTES:

    ---------------------------

    It's annoying and complicated to create a game server.

    It's really nice that it's completely configurable,
    but the config being passed in to the constructor makes it
    difficult to create a derived class that just creates how
    it wants to.

    Maybe an init method would be a better idea? Even if it's internal...

    I really want the game client and server to be self contained, eg. own all objects they use

    ---------------------------

    I want the client to have callbacks for pretty much everything that happens, eg. 
    te be able to get callbacks on client connect, disconnect, to be able to override
    packet receives (eg. process more packet types) and so on.

    ---------------------------

    The network simulator is coded in such a way that it is annoying to use
    for a real application. I don't want it to randomly cycle between settings
    automatically. I want the user to be able to choose between a series of presets.

    ---------------------------

    It's really annoying not being able to create an address passing in dynamic port,
    eg. Address( "::1", ServerPort ) should be a thing.
    
    ---------------------------

    Client connect takes over 1 second. Optimize!

    ---------------------------
    