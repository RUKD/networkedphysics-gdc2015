DONE:

TODO:

    Design a function to render a bunch of go stones, eg. pass in the transforms as an array

    Look down at a grid of 19x19 go stones.

    Implement a framerate counter.

    Can I render 19x19 stones on the macbook?

    ----------------------------

    Fix stone shader so it works and renders some very basic lighting.

    ----------------------------

    Mesh manager should support a reload method, which just reloads
    all meshes it currently has loaded.

    ------------------------------

    Need to clean up the way I read and write to files.

    The binary read/write using ad-hoc stuff is a bit ugly.

    It would be nice to have a standardized file wrapper to do this,
    with a bit less effort, eg. File class.

    ------------------------------

    Get the virtual go tests running and passing, eg. TestVirtualGo.cpp

    Restructure the virtual go code so it's simple and compiles quickly without exposing too much impl in headers.

    Clean up awful shader loader code iostream and std::string bullshit

    ------------------------------

    Fix up the creation of the game client so it's not stupid.

    Fix up the game client memory leaks on shutdown. 

    It's important to detect leaks as soon as they happen!

    ------------------------------

    I would like a texture manager (seems that OpenGL does most of this, but could make it a bit easier...)

    By tracking all the textures loaded from disk, we can reload them as required, eg. reload textures.

    ------------------------------

    I would like a JSON scene language that describes what objects to create and where to place them.

    This will allow me to create demo scenes for go board and work on renders without writing C++ code
    to place the objects.

    Alternatively, I could embed a scripting language and use that to set up scenes.

    ------------------------------

    Explore physically based shading with go stones. I want a level that is an array 
    of go stones with varying physically based properties changing in a grid, like
    the typical physically based shading tests with spheres.

    Talk to Steve Marton at work to determine where to get started.

    ------------------------------

    Implement a quake style console.

    The console should have its own JSON file, eg. Console.json

    Inside this it should specify the fonts to be used by the console.

    The console should be capable of reloading its settings on the fly.

    Redirect stdout and stderr output to the console.

    Implement keyboard input to type text into this console.

    ------------------

    Implement some sort of key binding system, eg. bind a key to an action

    Use this key binding system to bind keys to pageup, pagedown, ctrl-up, ctrl-down
    and so on to control the console. Don't hardcode it!

    This probably requires implementing the concept of "FOCUS"

    eg. the game has focus, vs. the console having focus.

    We need a window manager or a focus manager or something. The game needs to have
    it's own interface on the client that implements input focus so it is passed
    inputs when the console doesn't have focus.

    ------------------

    Have console off by default (previous was on)

    Implement key binding "~" to toggle the console on off

    Implement escape to quit the game (maybe with yes/no prompt, with enter/escape as cancel?)

    Implement command history buffer, eg. up-down

    Implement scrolling in this console buffer, eg. page-up page-down, ctrl-up, ctrl-down,
    command-up, command-down.

    ------------------

    Implement console commands on client

    Implement quit console command, connect console command and disconnect.

    Should be able to connect to a server, disconnect from it, reconnect, then quit.

    ------------------

    Color the commands nicely so errors are colored, commands are colored,
    output from the game log is colored and so on.

    Put these color configurations inside config json files, eg. data/config/Console.json

    ------------------

    Add a log as well, output to client.log on server.log with append.

    Make sure that when a new instance of the program runs it puts a new
    header in there, or =========================== or something similar.

    ------------------

    Learn how to use chef/knife to setup the linux server properly with all
    the stuff I want automatically, vs. manually configuring it. eg. git,
    GCC and all that.

    Get the server loop setup properly. Server needs to update game and then sleep
    until time has elapsed for next frame. I think I have this code available
    from previous projects. Resurrect it.

    Find a nifty way with scripts to update the server on request, or automatically
    when git is checked in.

    Get the client/server workflow really tight!

    ------------------------------

    Add concept of console commands and console variables

    Hook up concept of client and server side console commands / convars

    Work out how to transmit these to the client on initial connect
    and then on each change.

    ------------------------------
