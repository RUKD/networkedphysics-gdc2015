DONE:

TODO:

    Add a test to the reliable message unit test that stresses the case where not all
    messages fit into the packet.

    Move the configuration of channel budget out of the channel config (static)
    and in to the connection. 

    Channel budget should potentially be a dynamic thing, and the user should
    be able to derive their own connection type and specify channel budgets
    dynamically based on flow control, for example.

    --------------------

    Implement large block serialization.

    User should be able to specify a block fragment size in config.

    We need to know maximum # of fragments per-block. I'm thinking 65535

    Might be nice to add a validate step to the config for connection/channels

    ----------------------

    Setup a large variety of different message types, eg. small blocks, large blocks
    large messages, small messages and so on. Make the packet size quite small so it
    is continually being exercised and make the test smart enough to fill the send
    queue up massively, as much as can be done without overflowing it, stress the
    system as hard as possible!

    --------------

    Split project into .cpp and .h

    Setup premake.

    Setup basic lib structure: libprotocol

    Move the socket and system programming includes out of Common.h 
    and into Address.cpp and BSDSocketsInterface.cpp as required

    Need a way to build all tests and check they pass easily,
    eg. probably need some way for "TEST( test_... )" to register
    the set of tests with a static vector of test functors.

    Add UnitTest.cpp

    ------------------------

    Implement client and server interface.

    These should allow you to pass in a network interface, and then manage
    the set of connections on the server, one-per client', and on the client
    just have a single connection to the server.

    Note that there probably needs to be a state machine on the server
    and on the client to negotiate connection. Once connection is established
    the connection stabilizes mostly to the "Connection" packet type.

    Should also implement a reservation system at this point, with a reservation
    token, eg. reserve 4 slots for token X. Timeout or succeed the reservation
    and so on.

    --------------------

    It would be nice to bring back templated serialize functions, and have specialized
    read, write and measure streams. I think the code generated would be much more
    amenable to optimization, however before doing this I should definitely profile.

    ---------------------

    What is next?

    1) Implement the bit packer. This is quite important to actually be taken seriously. -- DONE

    2) Start doing performance analysis (CPU, memory etc.)

    3) Investigate using a custom allocator. Potentially ditch STL usage at this point.

    4) Consider cost of shared_ptr. Is it slow? Where should I use it? Where should I not?

    5) Integrate the oodle library. Provide an #if USE_OODLE 1 type thing and hook it up
       for compression. Try it out in the stress test and see how it generates dictionaries
       and how much compression it gets post-dictionary and so on. Do not check in the oodle
       libs, but do check in the interface and source code that uses it.

    6) Implement encryption via key, plus hash to detect tampering (unified). Optional feature.

    7) Implement an unreliable channel (messages), 
       eg. queue up unreliable messages to send and discard any that don't fit in the packet.
       Bonus: Provide an optional functor to sort the unreliable messages in order of importance.

    8) Implement an atomic queue on top of the client and server interface for sending
       and receiving user packets. This interface should allow running the actual serialization
       and packet reading entirely on a separate thread. Do it here where it is most natural,
       to avoid overcomplicating the interface/connection code.
