DONE:

TODO:

    Work out how the user adds channels and works with them?

    My guess is the user owns the channels and gives shared ptr to connection,
    then the user can continue to work with the channels defined natively
    eg. talk directly to them so they have their own interfaces.

    No need to work through the connection class to get to channels!

    Define channel base class functions

    It must:

        a) process acks
        b) bool HasData()
        c) Serialize
        d) should also have functions that get called on successful serialize read/write and fail (discards etc.)
        e) It should have the ability to decide the data is crap *post* deserialize and discard packet

    Implement connection packet serialize fn. eg: skip per-channel if it doesnt have data to write.

    Implement a simple channel serializer that just sends blocks of data
    eg. BlockChannel -- stupid serialize sends bytes per-block, then
    block data. Only one block per-packet.

    Verify that everything works.

    Channel should have basic stats per-channel, eg. how much data is read/written per-channel.

PROTOCOL AND SERVER:

    Install Captain Proto

    Work out how to use it for internet messages between servers

    Google snappy looks like a nice candidate for message compression

    Is there a nice library for message encryption between servers over UDP?
    (eg. a shared secret is fine, server code is not distributed)

    Nettle library looks OK. Does google have a library that they use?

    On write:

        serialize write -> compress -> encrypt -> sign -> send

    On read:

        recv -> verify signature -> decrypt -> serialize read

OPTIMIZATION:

    Implement bit packer first.

    Next try to implement range encoder.

    Study range encoder. How does it work? Can the decryption be done in place as per bitpacker?

    Send and receive queues should be lockless threadsafe

    Separate send and receive threads for NetworkInterface

    Investigate different methods for sending and receiving UDP packets,
    eg. completion ports on Win32, whatever method is fastest on linux etc.

    Run throughput tests with linux hosts. Test CPU usage etc.
