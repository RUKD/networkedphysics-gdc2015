DONE:

TODO:

    Exchange messages between client and server and if no messages
    are received for several seconds then that is an error.










    -----------------------

    A 64 bit client and server guid is a bit overkill.

    Maybe drop these guys down to say, 16 bits each? :D

    Then once this is done, we could include client and server guid
    inside the connection packet and not feel too bad.

    Next to move the check against client and server guids for
    connection packet, because we should only ever *serialize*
    a connection packet if its client and server guids match
    the expected set.

    -----------------------

    Implement concept of "context" for packets. Maybe this can
    be done in such a way that client server packet context is 
    expected for connection packets.

    This is important because connection packets will shortly
    only be *serializable* if the client and server guids match.

    If they don't match then the packet could be from a different
    client/server connection with different server data, and hence
    not serializable without error.

    -----------------------------

    Stream should have a context, eg. a void* that could be accessed within
    serialize functions.

    Inside this context, stuff like server data could be put, so messages
    could encode against something transmitted from server to client.

    eg. send table, num classes, num properties in a class and so on.

    This is actually quite important, and is the whole reason why I went
    to such an effort to implement the client and server data so early.

    ----------------------------

    Implement concept of "context" for messages.

    This would allow messages inside the connection packet to
    be serialized and deserialized against non-const static data,
    eg. numbers of various things, mins/max that could be different
    per-server, or different versions of a server.

    This would also allow super-efficient serialization for send tables.

    ------------------------











    ------------------------

    Integrate LZ compressor for compressing large blocks, and for compressing
    initial block sent down to client.

    Ideally, LZ4 could be something enabled via config that is used, if it exists
    this way it is up to the user of the library to ensure they have LZ4 installed.

    I don't want to manage the LZ4 library includes/libs inside my library,
    if I can avoid it.

    It might be a good idea to see if LZ4 can compress typical packets sent as well,
    for example, put a bit in the header indicating that the packet is compressed,
    if LZ4 is enabled, and then decode the packet via LZ4.

    This would have to live at the network interface level, presumably.

    Potentially set a minimum packet size or block size for LZ compression,
    and even then, check if the compressed packet/block is larger than uncompressed
    and send uncompressed instead.

    Per-packet or block (large block), we would need a bit indicating if compressed.

    ------------------------

    Implement fragmentation and reassembly for large packets, do this
    at the connection level once we have large snapshots, this would
    probably be a good idea to have -- set MTU to 1200 bytes.

    Keep it simple. A packet is received when all its fragments
    have been received. If any of the fragments are dropped,
    then the packet is dropped.

    I propose a simple header, eg. a packet type for fragment packet
    with a header x/y fragments and the sequence number of the *unacked*
    packet.

    Then the complexity becomes:

    a) writing the fragments, and not sending them out too rapidly
    b) on the receive side collating the fragments and reassembling them.

    ------------------------

    Where does fragmentation and reassembly live?

    Ideally, I would like for it to be in the connection layer
    or at least somewhere that it doesn't need to be implemented
    from scratch with each different network interface implementation.

    Is this possible?

    Maybe it should just be at the interface level.

    ------------------------







    *** SEND TABLES ***

    ---------------

    Implement send table concept. Implement delta encoding tables etc.

    Use the server data to communicate this table down to the client.

    ------------------------

    Actually implement a client/server setup and host the server in the cloud.

    Provide build steps using chef/knife or whatever to easily deploy this server.

    ------------------------









WOULD BE NICE:

    -----------------------------

    Would be nice to create an address by string, and then have a port override arg

    -----------------------------

    May be a good idea to offer a small block of data (less than one packet)
    that is included in the challenge response.

    The reason is that it could be game specific, and would inform the client
    of what it should be doing, eg. precache this level, so it doesn't have to
    wait for the server and data client exchange before doing that.

    --------------------------

    Idea: Packets could store a context pointer, and on creation it could optionally
    be passed in, per-packet type in the factory. It would be up to the user to setup
    and create this context, and per-packet type to cast to the expected type.

    I guess one context for client/server with some basic quantities needed for
    serialization would probably be a good idea. This is a nice idea.

    Same concept could be applied to messages. Although, it's potentially expensive,
    eg. another 64bit pointer per-message just for some basic context -- maybe for
    messages it's better to pass it in the serialize instead (eg. factory GetContext(type) ) ?

    ----------------------

    Clean up the resolver so that it doesn't perform dynamic allocations.

    Find a way to move the future into the implementation (cpp)
    so we don't need #include <future> in a header file.

    Remove std::string usage from Resolver interface and DNSResolver.

    ----------------------

    Should be able to determine if scratch allocator is being exhausted,
    and falling back to malloc, eg. add a check, and then check this once
    per-frame inside the soak test -- i definitely *dont* want the scratch
    falling back to malloc inside soak test.

    Alternatively, add a flag so it asserts if it has to fallback to scratch,
    but disable this by default because otherwise it won't pass the unit test.

    -------------

    I would like the scratch allocator to be more resilient in  debug builds, 
    eg. for it to have safety checks, eg. missing magic # where expected, assert.

    --------------------

    I don't like the bool ipv6. Use address type instead, eg. ADDRESS_IPV6

    --------------------

    Restructure so that precompiled headers are used.

    Add timing to build steps so the efficiency can be measured.

    ----------------------

    Unit tests to add:

    Move the murmur hash test into TestCommon.cpp

    Verify that channel error percolates down and makes the server disconnect client,
    *and* on client side, makes the client disconnect from server.

    Make sure error is properly cleared on reset.

    Make sure we don't leak memory on connection reset (client reconnect should do this)

    ----------------------

    Google have some cool allocators. Check them out.

    ---------------------

    Branimir has an stl replacement with allocator support.

    Check it out. "BZ"

    ----------------------

    Add some macros to make defining serialization and messages easier.

    ----------------------

    Basic logging. Just start with a "Log" macro that can be redirected
    to a "Logger" interface via virtual fn. 

    Of course, this is disabled in release build (NDEBUG) but it is 
    the easiest way to make sure the library can output logs to the
    appropriate place (console, TTY, file, whatever...)

    Should logs include the "\n" at the end?

    It would be nice if they didn't have to. It's easy to forget.

    --------------------

    Optimization for fragments, track oldest unacked fragment id, and start there
    and go left to right to search for fragments to send.

    --------------------

    Add a new fragmentSendWindow config, eg. 64 and only look this far past
    the oldest unacked fragment. Should save unnecessary scans for large block
    sizes.

    --------------------

    Could save a bit of memory and maybe gain some speed by switching 
    the received fragment data to a bitfield

    We only need one bit per-fragment, "has it been received?"

    ----------------

    Idea for logging, have an enum of channels, and per-channel a level integer
    Initial level is zero. Enable logging by setting the level. Per-channel logs
    can be emitted by passing the level, which defaults to 1.

    Log( "hello everybody %d\n", value );

    On a per-file basis, specify the current log channel via #define

    This may require the project gets split up into cpp files first.

    ----------------

    For the message and block allocator, I'm thinking of a thread
    local storage allocator that detects when the thread that is
    calling it is *not* the same as the thread that it is running
    on, and in this case adds the deallocs to a list (atomic) which 
    is processed inside the allocator update.

    Alternatively, received messages could just have a policy
    that they will be deleted on the next update. Don't hold
    on to them.

    Same for blocks, potentially.

    ----------------

    Add counters for all the different things inside the large blocks,
    eg. # of large blocks sent, received, read/written, also # of
    fragments read/written.

    Write some basic tests to verify these counters are functional.

    ------------------

    Might be nice to add a validate step to the config for connection/channels
    because it's possible to specify a config that doesn't work now. eg. 
    interdependent parameters.

    Would be nice if the reliable message channel could report the minimal functional
    budget that would work for it, given its configuration. This would be great
    for the connection to budget for the channel.

    This should be in the base class for channel interface, so we can generically
    work with and budget channels decently without knowing exactly what they are.

    ----------------------

    Move the channel budget out of the channel config (static)
    and in to the connection. 

    Channel budget should be dynamic. The user should be able to derive their own 
    connection type and specify channel budgets dynamically based on flow control, 
    for example.

    ---------------------

    Implement packet encryption via key, plus hash to detect tampering (unified). Optional feature.

    ---------------------

    Implement an unreliable channel (messages), 
    eg. queue up unreliable messages to send and discard any that don't fit in the packet.
    Bonus: Provide an optional functor to sort the unreliable messages in order of importance.

    --------------------

    Implement an atomic queue on top of the client and server interface for sending
    and receiving user packets. This interface should allow running the actual serialization
    and packet reading entirely on a separate thread. Do it here where it is most natural,
    to avoid overcomplicating the interface/connection code.

    ----------------
