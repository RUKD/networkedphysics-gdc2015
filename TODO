DONE:

TODO:

    -------------------------------------------

    Add a network simulator so I can do the packet delay and packet loss with little effort.

    Pump the network simulator update inside demo update

    Implement code to dequeue packets from the simulator and process them according to address.

    Left should be address ::1 but with port 1000, right should be port 1001.

    This way the address can determine flow, and packets can go left <->right with same simulator.

    -------------------------------------------

    Each frame on the left simulation (0) I need to take the input and frame number
    and insert that into the sliding window (&0xFFFF).
    
    If inserting a packet into the sliding window would overwrite an existing entry
    then this is an error. Assert.

    This assert may be annoying initially so perhaps disable it with a // todo

    -------------------------------------------

    Each frame write a packet to the right simulation (1)

    This packet should include the most recent sequence and all the inputs
    from the oldest sequence to the current (eg. num inputs)

    Inputs should be written from oldest to newest order because this is cache efficient.

    -------------------------------------------

    Make sure to actually serialize read/write packets when they pop out of the simulator

    I want to make sure the serialization is actually done.

    This makes it "real networking" as far as I am concerned, vs. passing structures around.

    -------------------------------------------

    On the receiving side I don't need a queue since all inputs are in the packet.

    Wait. No I do need a queue because I don't just playback the data on receive,
    I will buffer that data, add a timestamp and then when the playout delay buffer
    says it is time, that input comes out and we simulate a frame.

    -------------------------------------------

    Each frame, if a packet was received that frame (eg. added to playout buffer) 
    send just one ack packet, this ack should just contain the most recent sequence
    # received. This is what is sent back as ack.

    -------------------------------------------

    This means I need to implement a *simple* playout delay buffer, even if it's
    just something like, OK, what is the time on the server, OK this packet should
    play now (server time should be first packet receive - 100ms or so)

    -------------------------------------------

    When processing acks it's really easy. Just clear all inputs in the client input
    sliding window that are not more recent than the ack sequence #.

    -------------------------------------------

    I think I want 100ms of actual latency, and 100ms of playout delay.

    Calculate this according to # of frames sent, eg. how many packets can you lose
    in a row before you see a dip.

    Basically at 100ms playout delay, you are OK unless you lose 6 packets in a row @ 60pps.

    -------------------------------------------










    *** PHASE TWO ***

    -------------------------------------------

    Add a way to simulate packet loss and increase/decrease it

    Visualize the amount of packet loss with a text display somewhere

    -------------------------------------------

    Add a way to increase/decrease latency

    Determine if we have to do something to catch up / speed up / slow down because of this

    -------------------------------------------

    Implement a more TCP like reliability system, eg. only resend if packet is detected lost

    This will show that UDP reliability can be better than TCP for this situation.

    -------------------------------------------

















    -------------------------------------------

    Actually write the "Deterministic Lockstep" article

    Now implement a reliability system between left and right simulation, eg. track sequence and ack,
    and include *all* inputs since last acked sequence.

    Note in the article it would be nice to be like, "OK. Lets beat TCP at its own game" 
    and then link to the reddit discussion saying why write your own TCP? Gaffer is flawed etc.

    Fuck those guys. I'm going to nail them.

    -------------------------------------------







    -------------------------------------------

    Snapshots demo

    -------------------------------------------

    Stateful demo

    -------------------------------------------

    Write rest of article series

    -------------------------------------------

    Polish cube demo implementation as much as possible

    Port to windows and make sure it runs on Win64

    Release source code for singleplayer, lockstep, snapshot and stateful demos.

    -------------------------------------------

    Prepare GDC slides from article series

    -------------------------------------------






    --------------------------------------------------------------

    Explore various different interpolation strategies to use for 2D linear motion.

    Share this demo with Nathan (pro-bono) and try to get some involvement back with their project.

    --------------------------------------------------------------

    Return to PBR rendering

    --------------------------------------------------------------

    Convert DDS loading to use nvImage to load HDR uffizi cubemap.

    Work on exposure and get the scene looking good with HDR, may need to bump up direct light intensity?

    ----------------------------------

    Get roughness working with this HDR cubemap, eg. use roughness to index the mip chain.

    Look into a normalized BRDF function that accepts roughness, eg. microfacet model.

    ----------------------------------

    Get fresnel working so some reflection is visible even on the diffuse stone and more 
    reflection is visible at grazing angles (quite important for realistic go stone visuals)

    ----------------------------------

    Reread Seb Legarde stuff again start to finish.

    http://seblagarde.wordpress.com/2011/08/17/hello-world/

    Dig in a bit deeper into the source material (especially Naty's siggraph talks)
    and understand the math and physical reasoning behind it.

    Start here:

    http://renderwonk.com/publications/s2010-shading-course/hoffman/s2010_physically_based_shading_hoffman_a_notes.pdf

    ----------------------------------

    Continue studying trip through the graphics pipeline.

    ----------------------------------

    Identify areas where my math is weak and work to study those parts.

    Khan Academy? Probably the best bet to start.

    Get a desk so I can study.

    ----------------------------------

    Get go board rendering working

    ----------------------------------

    Render skybox and then in-game, render a cubemap from the center of a stone (size 35?)

    Make sure this cubemap is captured in HDR, eg. pre-tonemapping.

    This cubemap can then be input into CubeMapGen or cmft to get a correct radiance 
    and irradiance cubemap including the go board in the scene, eg. reflected color of the wood.

    ----------------------------------

    Research raytracing signed distance fields for shadows

    ----------------------------------
