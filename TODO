DONE:

    Indeed the remaining "error" in the smallest three compression was that negative w
    was not being considered.

    Added another bool "quaternion_negative_w" to know when to negate the w.

    There is still another error that occurs, I suspect to do with smallest 2 breaking down
    (eg. blinking out of existence). 

    I may need to send more bits or identify the largest component post 

TODO:

    Should probably fix this before going further with the smallest 2 for axis.

    -----------------------------------------------

    Write out data files: "orientation_data.txt", "position_data.txt"

    Write logic to setup array of objects with # of bits per-axis and per-angle
    to use, and a function to run over the sample data and calculate average #
    of bits per-orientation.

    Sort the output then by the # of bits calculated, and print out the top ten encodings for orientation.

    Just try the simplest thing for now, eg. just want to know if the simple technique is worthwhile
    and what % of bits it saves.

    Once this is done, try to answer more advanced questions:

        - do we need 2 bits to represent smallest two for axis?
        - if we encode smallest 2 bits then we need to encode whether or not it is negative as well
