DONE:

    Restructure code into various headers so I can have multiple programs.

        Common.h
        Stream.h
        Network.h
        Connection.h
        MessageChannel.h

    Split up unit tests into separate cpp per-aspect, eg. TestMessageChannel.cpp

    Split up the code so that each section has minimum dependencies.

    Problem. I would really like packet to be independent of network.

    Solution: Move address out of network.h

    Moved Packet.h out of Network.h

    Moved Channel.h out of Connection.h

    Moved Message.h out of MessageChannel.h

    Move various X::Configs out into their own XConfig structs. More flexible.

    Create test harnesses for each module:

    eg: 

        TestCommon.cpp
        TestStream.cpp
        TestNetwork.cpp
        TestConnection.cpp

TODO:

    Need to simplify test_factory so it doesn't depend on packet types.

    It would be really nice if I could build any .h and it would actually build
    tests for that particular header, and test that it includes everything etc.

    Need an easy way to clean everything before I check in.

    It's probably a good idea to keep Resolver class separate from DNS resolver impl,
    interface class separate from network interface implementation

    And so on.

    --------------

    Implement stress test for message channel.

    --------------

    Extend message channel unit test to verify counters.    

    --------------
    
    Now implement code to measure events and determine if they can fit into packet.

    Should this measurement be done at the point of constructing the packet data? (probably)

    How to ensure that this measurement is done only once?

    Don't just append one stream to another, as it throws off the journal check.

    ------------------

    Implement special serialization for block messages.

    First, assume small blocks and write a specific serialization for small blocks
    that treats them like messages, eg. with serialize.

    However, for large blocks focus packet data exclusively on that block
    until all fragments of that block have been sent across.

    This way I can unify ordered delivery of messages, small blocks and large blocks.

    This is a very flexible system.

    ---------------------

    After the block serialization is implemented inside the message channel
    I have a very flexible protocol system.

    What is next?

    1) Implement the bit packer

    2) Start doing performance analysis (CPU, memory etc.)

    3) Investigate using a custom allocator. Potentially ditch STL usage at this point.

    4) Consider cost of shared_ptr. Apparently it is very slow. Come up with a replacement.

    5) Implement compression of large blocks before sending, decompress on receive.

    6) Implement encryption via key, plus hash to detect tampering (unified). Optional at 
       network interface layer.

    7) Implement an unreliable channel (messages), 
       eg. queue up unreliable messages to send and discard any that don't fit in the packet.

    8) Implement an atomic queue for message send and receive. Interface should be uniform,
       eg. an atomic queue for messages received (whether reliable or not), and an atomic
       queue for messages to send.
