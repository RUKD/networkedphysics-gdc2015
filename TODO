DONE:

TODO:

    ------------------------------------

    In the article discuss improvements past the smoothing but don't implement!
    
    Encode position relative to player cube as offset. Output the offsets as 
    data set and optimize to find the best bit encoding. xy vs. z, try one level
    and two level bits.

    Use reliability system to know which packets got through (link to article).

    Keep track of, per-cube the last sequence # it changed on. If it hasn't
    changed since that sequence lower its priority even further (still send it
    though...)

    Use reliability system to drive delta encoding. Per-cube need 16 bit sequence
    to identify base, receiver needs to buffer a lot of bases. If last sent packet
    exceeds time then the object isn't changing much, so the lowering priority
    if it is unchanged picks up this case.

    Note that prioritizing recently rest objects higher, eg. resending these just at
    rest objects more rapidly (not as high as moving, but higher than the rest)
    until a state with their update is acked would ensure that these at rest
    objects are rapidly "committed" to the other side (note that on post-smoothing
    fixup, often at rest objects "grey" fixes for these objects trickle in... 
    this would fix that!)

    Can do better than 16 bit base per-object. Moving objects get updated frequently, 
    so any object that has moved in the last 1 second @ 60pps = [0,63], 5 bits per-object,
    4 bits for 1/2 second, 2 bits for 1/4 second. Use statistics to identify the profitable
    bit range for deltas (depends on the average rate of update for moving objects)

    Idea, encode base sequence # per-object relative to most recent ack packet (header)

    If input changes and a packet is lost with that change there will be visual glitches

    To fix, add *some* small delay @ 60fps (85ms or so) to handle lost packets and 
    jitter, to make it *EXTREMELY* unlikely that an input would be lost, and then
    use the same technique from deterministic lockstep to redundantly send unacked
    inputs.

    However, go with smoothing instead because this is different to det lockstep.

    Two level smoothing.

    In fact, there is a continuum of the deterministic lockstep <-> this technique
    depending on how long you are willing to wait for input, if you wait forever, it's
    deterministic lockstep and state never needs to be sent, if you wait a finite amount
    of time, it's practically completely deterministic, but state is sent just to fixup
    when input is lost (1 second of packet loss)

    -------------------------------------------------------------------------

    Write conclusion article (pros/cons of each technique) ---> SHORT

    Need this because I need the arc of conclusion for the GDC talk.

        1. The simulation

        2. Deterministic lockstep

        3. Snapshots and interpolation

            *** snapshot compression worked example ***

        4. Stateful synchronization

        5. Conclusion: Pros/cons

        6. Question time: latency hiding, client/server, implementation details etc.

    -------------------------------------------------------------------------

    Make a list of diagrams that need to be created.

    Sketch out the diagrams roughly with pencil/paper.

    Once the basic outline is working hand over to Chantel to create the diagrams w. illustrator.

    Finish slides for GDC.

    -------------------------------------------------------------------------

    Update article with results of relative quaternion compression.

    70% of absolute smallest three.

    Don't have time to investigate further.

    Also mention axis-angle representation compression directly.

    -------------------------------------------------------------------------

    Implement javascript to pause video when it is not currently visible

    -------------------------------------------------------------------------
