DONE:

TODO:

    Move various X::Configs out into their own XConfig structs. More flexible.

    Restructure code into various headers so I can have multiple programs.

    Network.h
    Channel.h
    Connection.h
    MessageChannel.h

    Add UnitTest.cpp

    Add StressTest.cpp
    
    Implement stress test for message channel.

    --------------

    Extend message channel unit test to verify counters.    

    --------------
    
    Now implement code to measure events and determine if they can fit into packet.

    Should this measurement be done at the point of constructing the packet data? (probably)

    How to ensure that this measurement is done only once?

    Don't just append one stream to another, as it throws off the journal check.

    ------------------

    Implement special serialization for block messages.

    First, assume small blocks and write a specific serialization for small blocks
    that treats them like messages, eg. with serialize.

    However, for large blocks focus packet data exclusively on that block
    until all fragments of that block have been sent across.

    This way I can unify ordered delivery of messages, small blocks and large blocks.

    This is a very flexible system.

    ---------------------

    After the block serialization is implemented inside the message channel
    I have a very flexible protocol system.

    What is next?

    1) Implement the bit packer

    2) Start doing performance analysis (CPU, memory etc.)

    3) Investigate using a custom allocator. Potentially ditch STL usage at this point.

    4) Consider cost of shared_ptr. Apparently it is very slow. Come up with a replacement.

    5) Implement compression of large blocks before sending, decompress on receive.

    6) Implement encryption via key, plus hash to detect tampering (unified). Optional at 
       network interface layer.

    7) Implement an unreliable channel (messages), 
       eg. queue up unreliable messages to send and discard any that don't fit in the packet.

    8) Implement an atomic queue for message send and receive. Interface should be uniform,
       eg. an atomic queue for messages received (whether reliable or not), and an atomic
       queue for messages to send.
