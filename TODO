DONE:

TODO:

    Structure source code, eg. include / source / tests

    Extend message channel unit test to verify counters

    Split project into .cpp and .h

    Setup premake.

    Setup basic lib structure: libprotocol

    I can still build and run individual files via C++11 build rule.
    This is good to get quick feedback for compilation and fixing.

    Move the socket and system programming includes out of Common.h 
    and into Address.cpp and BSDSocketsInterface.cpp as required

    Need a way to build all tests and check they pass easily

    Need an easy way to clean everything before I check in

    To run soak tests I need to be able to build and run from console

    --------------
    
    Now implement code to measure events and determine if they can fit into packet.

    Should this measurement be done at the point of constructing the packet data? (probably)

    How to ensure that this measurement is done only once?

    Don't just append one stream to another, as it throws off the journal check.

    ------------------

    Implement special serialization for block messages.

    First, assume small blocks and write a specific serialization for small blocks
    that treats them like messages, eg. with serialize.

    However, for large blocks focus packet data exclusively on that block
    until all fragments of that block have been sent across.

    This way I can unify ordered delivery of messages, small blocks and large blocks.

    This is a very flexible system.

    ----------------------

    Now soak test that this is working correctly.

    Setup a large variety of different message types, eg. small blocks, large blocks
    large messages, small messages and so on. Make the packet size quite small so it
    is continually being exercised and make the test smart enough to fill the send
    queue up massively, as much as can be done without overflowing it, stress the
    system as hard as possible!

    ---------------------

    Would be nice to have a message channel base, and then derive 
    ReliableMessageChannel and UnreliableMessageChannel from this.

    This way multiple message channel implementations could share
    the same basic interface, eg. send and receive messages

    This is an excellent idea, and will unify message treatment
    for the client/server wrapper on top of the connection.

    --------------

    Implement client and server interface.

    These should allow you to pass in a network interface, and then manage
    the set of connections on the server, one-per client', and on the client
    just have a single connection to the server.

    Note that there probably needs to be a state machine on the server
    and on the client to negotiate connection. Once connection is established
    the connection stabilizes mostly to the "Connection" packet type.

    Should also implement a reservation system at this point, with a reservation
    token, eg. reserve 4 slots for token X. Timeout or succeed the reservation
    and so on.

    ---------------------

    What is next?

    1) Implement the bit packer. This is quite important to actually be taken seriously.

    2) Start doing performance analysis (CPU, memory etc.)

    3) Investigate using a custom allocator. Potentially ditch STL usage at this point.

    4) Consider cost of shared_ptr. Is it slow? Where should I use it? Where should I not?

    5) Itegrate the oodle library. Provide an #if USE_OODLE 1 type thing and hook it up
       for compression. Try it out in the stress test and see how it generates dictionaries
       and how much compression it gets post-dictionary and so on. Do not check in the oodle
       libs, but do check in the interface and source code that uses it.

    6) Implement encryption via key, plus hash to detect tampering (unified). Optional at 
       network interface layer.

    7) Implement an unreliable channel (messages), 
       eg. queue up unreliable messages to send and discard any that don't fit in the packet.

    8) Implement an atomic queue for message send and receive. Interface should be uniform,
       eg. an atomic queue for messages received (whether reliable or not), and an atomic
       queue for messages to send.
