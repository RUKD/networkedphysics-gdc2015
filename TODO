DONE:

    Try to implement basic dumb channel.

    Serialize write is working. Everything up to including channel data
    in the packet, and then serializing this channel data with skip bits
    works fine.

    Got up 

TODO:

    Add interface that lets connection packet:

        1. Get the number of channels
        2. Create data for a channel by channel #

    This will let the connection packet implement its serialize read.

    Once serialize read is working, the channel structure should be
    working from end-to-end, and should be able to read blocks from
    the receive queue.

    --------

    Implement simple reliable ordered block channel.

    Initially this will just send one block, wait for that blocks
    ack before allowing the next block to be sent.

    eg. block the "has data" until the current block has been
    acked. Consider resending that same block in a new packet
    until one packet containing that block has been acked.

    Next, should implement block fragmentation and reassembly.

    Idea is that small and large blocks can be sent reliably
    and in-order. These blocks are non-time critical.

    Idea: Although the packet size can vary widely, it would be
    nice to have a bandwidth rate cap per channel, a channel could
    artificially say it has no data if it has gone over the bandwidth
    usage over the past n seconds, this would allow bandwidth throttling
    even if the actual size of the block being sent is potentially
    quite a large chunk of the packet size.

    Eg. this is a simpler approach than trying to efficiently pack
    and throttle the data into a very small, fixed size packet,
    eg. 256 bytes 30 times per-second (64kbps roughly)

PROTOCOL AND SERVER:

    Cap'n Proto looks a bit overengineered (eg. second systems effect)

    MessagePack looks a bit smaller and tight to me, but probably less efficient
    over the wire and in terms of packing time.

    Are protocol buffers worth integrating?

    Google snappy looks like a nice candidate for message compression

    Is there a nice library for message encryption between servers over UDP?
    (eg. a shared secret is fine, server code is not distributed)

    Nettle library looks OK. Does google have a library that they use?

    On write:

        serialize write -> compress -> encrypt -> sign -> send

    On read:

        recv -> verify signature -> decrypt -> serialize read

    If I have my own reliable ordered block channel, I can then derive
    specific channels from that, eg. JSONChannel, CapnProtoChannel,
    MsgPackChannel, ThriftChannel and so on... should be easy to add
    additional libraries and try them out. Try them all! :D

OPTIMIZATION:

    Implement bit packer first.

    Next try to implement range encoder.

    Study range encoder. How does it work? Can the decryption be done in place as per bitpacker?

    Send and receive queues should be lockless threadsafe

    Separate send and receive threads for NetworkInterface

    Some ninja must be done to make it easy for the channels to work
    with serialization being done on a separate thread. Ouch?

    Investigate different methods for sending and receiving UDP packets,
    eg. completion ports on Win32, whatever method is fastest on linux etc.

    Run throughput tests with linux hosts. Test CPU usage etc.
