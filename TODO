DONE:

    Research modern OpenGL style.

    Seems I have an OpenGL 4.1 on my macbook.

    Shader model is 410.

    Research how to get shaders built and working for 410.,
    the example source I am working from doesn't seem to work
    (it appears to be older style?)

    Get a basic triangle up and being rendered.

TODO:

    Implement helper functions to create shaders and so on.

    Move the shaders out of the C++ and in to shaders/*

    Implement ln -s bin/data/shaders -> data/shaders so I don't
    have to copy the shaders across all the time in the build step.

    Implement shader manager than loads in all shaders in directory
    and gives them names, you can search for shaders 

    Implement a default shader so if a particular shader fails
    to load, you have a basic pink shader to fall back to. 

    This shader should never change and should always compile.

    Make sure my code is clean and properly cleans up all shader
    data as required on shutdown.

    Implement function to reload shaders, this will eventually
    be called from a console command while the game is running.

    ------------------------------

    Order the ebook with company account for OpenGL 4.0 shading 
    language. Too many tutorials on the net are pre-4.0 shader lang
    so it is extremely frustrating going through old material!

    Get a book and tutorial set that are specific to 4.0 and skip the previous stuff!

    ------------------------------

    Get text rendering with modern OpenGL

    Make sure to offset the text by a small amount for the "diamond"
    rasterization rule so I can be guaranteed 1:1 ration of texels
    to pixels.

    ------------------------------

    Remove all C++ BS from Fonts.cpp, exceptions, iostream etc.

    Font should have a "Load" function that can return true/false
    if it fails to load. Do not throw exceptions.

    Font should accept an allocator and do all allocations that way.

    It should use the temp allocator to create a temporary buffer
    for the image load and conversion step.

    ------------------------------

    Add "FontManager" class.

    Implement code to import all .font files found in bin/data/fonts/*.font

    There should be a runtime hash of all fonts, eg. lookup font by name.

    It should be possible to reload fonts at runtime, eg. console command "reload_fonts"

    This probably means that we shouldn't cache font pointers, eg. we should query
    a font by name once per-frame when it is needed.

    Or we should have a callback or notification, font reloaded that invalidates stuff.

    ------------------------------

    Implement a quake style console.

    Redirect stdout and stderr output to the console.

    Implement keyboard input to type text into this console.

    ------------------------------

    The console should have its own JSON file, eg. Console.json

    Inside this it should specify the fonts to be used by the console.

    The console should be capable of reloading its settings on the fly.

    ------------------

    Implement some sort of key binding system, eg. bind a key to an action

    Use this key binding system to bind keys to pageup, pagedown, ctrl-up, ctrl-down
    and so on to control the console. Don't hardcode it!

    This probably requires implementing the concept of "FOCUS"

    eg. the game has focus, vs. the console having focus.

    We need a window manager or a focus manager or something. The game needs to have
    it's own interface on the client that implements input focus so it is passed
    inputs when the console doesn't have focus.

    ------------------

    Have console off by default (previous was on)

    Implement key binding "~" to toggle the console on off

    Implement escape to quit the game (maybe with yes/no prompt, with enter/escape as cancel?)

    Implement command history buffer, eg. up-down

    Implement scrolling in this console buffer, eg. page-up page-down, ctrl-up, ctrl-down,
    command-up, command-down.

    ------------------

    Implement console commands on client

    Implement quit console command, connect console command and disconnect.

    Should be able to connect to a server, disconnect from it, reconnect, then quit.

    ------------------

    Color the commands nicely so errors are colored, commands are colored,
    output from the game log is colored and so on.

    Put these color configurations inside config json files, eg. data/config/console.cfg

    Find a cheap JSON parser I can include for config files.

    I typically want new JSON configs read to override values for old, is this possible
    with JSON parsers easily? eg. overrides. This is important for users to be able to
    override settings specified by the game.

    Not sure if JSON is the correct solution anymore. May be too complex (don't need tree)

    ------------------

    Add a log as well, output to client.log on server.log with append.

    Make sure that when a new instance of the program runs it puts a new
    header in there, or =========================== or something similar.

    ------------------

    Learn how to use chef/knife to setup the linux server properly with all
    the stuff I want automatically, vs. manually configuring it. eg. git,
    GCC and all that.

    Get the server loop setup properly. Server needs to update game and then sleep
    until time has elapsed for next frame. I think I have this code available
    from previous projects. Resurrect it.

    Find a nifty way with scripts to update the server on request, or automatically
    when git is checked in.

    Get the client/server workflow really tight!

    ------------------------------

    Add concept of console commands and console variables

    Hook up concept of client and server side console commands / convars

    Work out how to transmit these to the client on initial connect
    and then on each change.

    ------------------------------

NOTES:

    ---------------------------

    It's annoying and complicated to create a game server.

    It's really nice that it's completely configurable,
    but the config being passed in to the constructor makes it
    difficult to create a derived class that just creates how
    it wants to.

    Maybe an init method would be a better idea? Even if it's internal...

    I really want the game client and server to be self contained, eg. own all objects they use

    ---------------------------

    I want the client to have callbacks for pretty much everything that happens, eg. 
    te be able to get callbacks on client connect, disconnect, to be able to override
    packet receives (eg. process more packet types) and so on.

    ---------------------------

    The network simulator is coded in such a way that it is annoying to use
    for a real application. I don't want it to randomly cycle between settings
    automatically. I want the user to be able to choose between a series of presets.

    ---------------------------

    It's really annoying not being able to create an address passing in dynamic port,
    eg. Address( "::1", ServerPort ) should be a thing.
    
    ---------------------------

    Client connect takes over 1 second. Optimize!

    ---------------------------